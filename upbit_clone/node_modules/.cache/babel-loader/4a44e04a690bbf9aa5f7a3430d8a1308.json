{"ast":null,"code":"import _slicedToArray from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { ascending, descending, histogram as d3Histogram, max, merge, rollup, sum, zip } from \"d3-array\";\nimport { scaleLinear } from \"d3-scale\";\nimport * as React from \"react\";\nimport { accumulatingWindow, functor, head, identity, getAxisCanvas, GenericChartComponent, last } from \"@react-financial-charts/core\";\nexport var VolumeProfileSeries = /*#__PURE__*/function (_React$Component) {\n  _inherits(VolumeProfileSeries, _React$Component);\n\n  var _super = _createSuper(VolumeProfileSeries);\n\n  function VolumeProfileSeries() {\n    var _this;\n\n    _classCallCheck(this, VolumeProfileSeries);\n\n    _this = _super.apply(this, arguments);\n\n    _this.drawOnCanvas = function (ctx, moreProps) {\n      var xAccessor = moreProps.xAccessor,\n          width = moreProps.width;\n\n      var _this$helper = _this.helper(_this.props, moreProps, xAccessor, width),\n          rects = _this$helper.rects,\n          sessionBg = _this$helper.sessionBg;\n\n      _this.drawOnCanvasContext(ctx, rects, sessionBg);\n    };\n\n    _this.drawOnCanvasContext = function (ctx, rects, sessionBg) {\n      var _this$props = _this.props,\n          sessionBackGround = _this$props.sessionBackGround,\n          showSessionBackground = _this$props.showSessionBackground;\n\n      if (showSessionBackground) {\n        if (sessionBackGround !== undefined) {\n          ctx.fillStyle = sessionBackGround;\n        }\n\n        sessionBg.forEach(function (each) {\n          var x = each.x,\n              y = each.y,\n              height = each.height,\n              width = each.width;\n          ctx.beginPath();\n          ctx.rect(x, y, width, height);\n          ctx.closePath();\n          ctx.fill();\n        });\n      }\n\n      rects.forEach(function (each) {\n        var x = each.x,\n            y = each.y,\n            height = each.height,\n            w1 = each.w1,\n            w2 = each.w2,\n            stroke1 = each.stroke1,\n            stroke2 = each.stroke2,\n            fill1 = each.fill1,\n            fill2 = each.fill2;\n\n        if (w1 > 0) {\n          ctx.fillStyle = fill1;\n\n          if (stroke1 !== \"none\") {\n            ctx.strokeStyle = stroke1;\n          }\n\n          ctx.beginPath();\n          ctx.rect(x, y, w1, height);\n          ctx.closePath();\n          ctx.fill();\n\n          if (stroke1 !== \"none\") {\n            ctx.stroke();\n          }\n        }\n\n        if (w2 > 0) {\n          ctx.fillStyle = fill2;\n\n          if (stroke2 !== \"none\") {\n            ctx.strokeStyle = stroke2;\n          }\n\n          ctx.beginPath();\n          ctx.rect(x + w1, y, w2, height);\n          ctx.closePath();\n          ctx.fill();\n\n          if (stroke2 !== \"none\") {\n            ctx.stroke();\n          }\n        }\n      });\n    };\n\n    _this.helper = function (props, moreProps, xAccessor, width) {\n      var realXScale = moreProps.xScale,\n          yScale = moreProps.chartConfig.yScale,\n          plotData = moreProps.plotData;\n      var sessionStart = props.sessionStart,\n          bySession = props.bySession,\n          partialStartOK = props.partialStartOK,\n          partialEndOK = props.partialEndOK;\n      var bins = props.bins,\n          maxProfileWidthPercent = props.maxProfileWidthPercent,\n          source = props.source,\n          volume = props.volume,\n          absoluteChange = props.absoluteChange,\n          orient = props.orient,\n          fill = props.fill,\n          stroke = props.stroke;\n      var sessionBuilder = accumulatingWindow().discardTillStart(!partialStartOK).discardTillEnd(!partialEndOK).accumulateTill(function (d, i) {\n        return sessionStart(Object.assign({\n          d: d,\n          i: i\n        }, moreProps));\n      }).accumulator(identity);\n      var dx = plotData.length > 1 ? realXScale(xAccessor(plotData[1])) - realXScale(xAccessor(head(plotData))) : 0;\n      var sessions = bySession ? sessionBuilder(plotData) : [plotData];\n      var allRects = sessions.map(function (session) {\n        var begin = bySession ? realXScale(xAccessor(head(session))) : 0;\n        var finish = bySession ? realXScale(xAccessor(last(session))) : width;\n        var sessionWidth = finish - begin + dx;\n        var histogram2 = d3Histogram().value(source).thresholds(bins);\n\n        var rolledup = function rolledup(data) {\n          var sortFunction = orient === \"right\" ? descending : ascending;\n          var sortedData = data.sort(sortFunction);\n          return rollup(sortedData, function (leaves) {\n            return sum(leaves, function (d) {\n              return d.volume;\n            });\n          }, function (d) {\n            return d.direction;\n          });\n        };\n\n        var values = histogram2(session);\n        var volumeInBins = values.map(function (arr) {\n          return arr.map(function (d) {\n            return absoluteChange(d) > 0 ? {\n              direction: \"up\",\n              volume: volume(d)\n            } : {\n              direction: \"down\",\n              volume: volume(d)\n            };\n          });\n        }).map(function (arr) {\n          return Array.from(rolledup(arr));\n        });\n        var volumeValues = volumeInBins.map(function (each) {\n          return sum(each.map(function (d) {\n            return d[1];\n          }));\n        });\n\n        var base = function base(xScaleD) {\n          return head(xScaleD.range());\n        };\n\n        var _ref = orient === \"right\" ? [begin, begin + sessionWidth * maxProfileWidthPercent / 100] : [finish, finish - sessionWidth * (100 - maxProfileWidthPercent) / 100],\n            _ref2 = _slicedToArray(_ref, 2),\n            start = _ref2[0],\n            end = _ref2[1];\n\n        var xScale = scaleLinear().domain([0, max(volumeValues)]).range([start, end]);\n        var totalVolumes = volumeInBins.map(function (volumes) {\n          var totalVolume = sum(volumes, function (d) {\n            return d.value;\n          });\n          var totalVolumeX = xScale(totalVolume);\n          var widthLocal = base(xScale) - totalVolumeX;\n          var x = widthLocal < 0 ? totalVolumeX + widthLocal : totalVolumeX;\n          var ws = volumes.map(function (d) {\n            return {\n              type: d[0],\n              width: d[1] * Math.abs(widthLocal) / totalVolume\n            };\n          });\n          return {\n            x: x,\n            ws: ws,\n            totalVolumeX: totalVolumeX\n          };\n        }); // @ts-ignore\n\n        var rects = zip(values, totalVolumes) // @ts-ignore\n        .map(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n              d = _ref4[0],\n              _ref4$ = _ref4[1],\n              x = _ref4$.x,\n              ws = _ref4$.ws;\n\n          var w1 = ws[0] || {\n            type: \"up\",\n            width: 0\n          };\n          var w2 = ws[1] || {\n            type: \"down\",\n            width: 0\n          };\n          return {\n            y: yScale(d.x1),\n            height: yScale(d.x1) - yScale(d.x0),\n            x: x,\n            width: width,\n            w1: w1.width,\n            w2: w2.width,\n            stroke1: functor(stroke)(w1),\n            stroke2: functor(stroke)(w2),\n            fill1: functor(fill)(w1),\n            fill2: functor(fill)(w2)\n          };\n        });\n        var sessionBg = {\n          x: begin,\n          y: last(rects).y,\n          height: head(rects).y - last(rects).y + head(rects).height,\n          width: sessionWidth\n        };\n        return {\n          rects: rects,\n          sessionBg: sessionBg\n        };\n      });\n      return {\n        rects: merge(allRects.map(function (d) {\n          return d.rects;\n        })),\n        sessionBg: allRects.map(function (d) {\n          return d.sessionBg;\n        })\n      };\n    };\n\n    return _this;\n  }\n\n  _createClass(VolumeProfileSeries, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(GenericChartComponent, {\n        canvasDraw: this.drawOnCanvas,\n        canvasToDraw: getAxisCanvas,\n        drawOn: [\"pan\"]\n      });\n    }\n  }]);\n\n  return VolumeProfileSeries;\n}(React.Component);\nVolumeProfileSeries.defaultProps = {\n  absoluteChange: function absoluteChange(d) {\n    return d.absoluteChange;\n  },\n  bins: 20,\n  bySession: false,\n  fill: function fill(_ref5) {\n    var type = _ref5.type;\n    return type === \"up\" ? \"#6BA583\" : \"#FF0000\";\n  },\n  maxProfileWidthPercent: 50,\n  orient: \"left\",\n  partialStartOK: true,\n  partialEndOK: true,\n  sessionBackGround: \"rgba(70, 130, 180, 0.3)\",\n  sessionStart: function sessionStart(_ref6) {\n    var d = _ref6.d,\n        i = _ref6.i,\n        plotData = _ref6.plotData;\n    return i > 0 && plotData[i - 1].date.getMonth() !== d.date.getMonth();\n  },\n  showSessionBackground: false,\n  source: function source(d) {\n    return d.close;\n  },\n  stroke: \"#FFFFFF\",\n  volume: function volume(d) {\n    return d.volume;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}