{"ast":null,"code":"import _toConsumableArray from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { ascending } from \"d3-array\";\nimport { scaleLinear } from \"d3-scale\";\nimport { levelDefinition } from \"./levels\";\nvar MAX_LEVEL = levelDefinition.length - 1;\nexport default function financeDiscontinuousScale(index) {\n  var backingLinearScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleLinear();\n\n  if (index === undefined) {\n    throw new Error(\"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\");\n  }\n\n  function scale(newScale) {\n    return backingLinearScale(newScale);\n  }\n\n  scale.invert = function (value) {\n    var inverted = backingLinearScale.invert(value);\n    return Math.round(inverted * 10000) / 10000;\n  };\n\n  scale.domain = function (newDomain) {\n    if (newDomain === undefined) {\n      return backingLinearScale.domain();\n    }\n\n    backingLinearScale.domain(newDomain);\n    return scale;\n  };\n\n  scale.range = function (range) {\n    if (range === undefined) {\n      return backingLinearScale.range();\n    }\n\n    backingLinearScale.range(range);\n    return scale;\n  };\n\n  scale.rangeRound = function (range) {\n    return backingLinearScale.rangeRound(range);\n  };\n\n  scale.clamp = function (clamp) {\n    if (clamp === undefined) {\n      return backingLinearScale.clamp();\n    }\n\n    backingLinearScale.clamp(clamp);\n    return scale;\n  };\n\n  scale.interpolate = function (interpolate) {\n    if (interpolate === undefined) {\n      return backingLinearScale.interpolate();\n    }\n\n    backingLinearScale.interpolate(interpolate);\n    return scale;\n  };\n\n  scale.ticks = function (m) {\n    var _a, _b, _c;\n\n    var backingTicks = backingLinearScale.ticks(m);\n    var ticksMap = new Map();\n\n    var _backingLinearScale$d = backingLinearScale.domain(),\n        _backingLinearScale$d2 = _slicedToArray(_backingLinearScale$d, 2),\n        domainStart = _backingLinearScale$d2[0],\n        domainEnd = _backingLinearScale$d2[1];\n\n    var dStart = Math.ceil(domainStart);\n    var dHead = (_a = index[0]) === null || _a === void 0 ? void 0 : _a.index;\n    var start = Math.max(dStart, dHead) + Math.abs(dHead);\n    var end = Math.min(Math.floor(domainEnd), (_b = index[index.length - 1]) === null || _b === void 0 ? void 0 : _b.index) + Math.abs(dHead);\n    var desiredTickCount = Math.ceil((end - start) / (domainEnd - domainStart) * backingTicks.length);\n\n    for (var i = MAX_LEVEL; i >= 0; i--) {\n      var ticksAtLevel = ticksMap.get(i);\n      var temp = ticksAtLevel === undefined ? [] : ticksAtLevel.slice();\n\n      for (var j = start; j <= end; j++) {\n        if (index[j].level === i) {\n          temp.push(index[j]);\n        }\n      }\n\n      ticksMap.set(i, temp);\n    }\n\n    var unsortedTicks = [];\n\n    for (var k = MAX_LEVEL; k >= 0; k--) {\n      var selectedTicks = (_c = ticksMap.get(k)) !== null && _c !== void 0 ? _c : [];\n\n      if (selectedTicks.length + unsortedTicks.length > desiredTickCount * 1.5) {\n        break;\n      }\n\n      unsortedTicks = unsortedTicks.concat(selectedTicks.map(function (d) {\n        return d.index;\n      }));\n    }\n\n    var ticks = unsortedTicks.sort(ascending);\n\n    if (end - start > ticks.length) {\n      var ticksSet = new Set(ticks);\n      var d = Math.abs(index[0].index); // ignore ticks within this distance\n\n      var distance = Math.ceil((backingTicks.length > 0 ? (backingTicks[backingTicks.length - 1] - backingTicks[0]) / backingTicks.length / 4 : 1) * 1.5);\n\n      for (var _i = 0; _i < ticks.length - 1; _i++) {\n        for (var _j = _i + 1; _j < ticks.length; _j++) {\n          if (ticks[_j] - ticks[_i] <= distance) {\n            ticksSet.delete(index[ticks[_i] + d].level >= index[ticks[_j] + d].level ? ticks[_j] : ticks[_i]);\n          }\n        }\n      } // @ts-ignore\n\n\n      var tickValues = _toConsumableArray(ticksSet.values()).map(function (i) {\n        return parseInt(i, 10);\n      });\n\n      return tickValues;\n    }\n\n    return ticks;\n  };\n\n  scale.tickFormat = function () {\n    return function (x) {\n      var d = Math.abs(index[0].index);\n      var _index$Math$floor = index[Math.floor(x + d)],\n          format = _index$Math$floor.format,\n          date = _index$Math$floor.date;\n      return format(date);\n    };\n  };\n\n  scale.value = function (x) {\n    var d = Math.abs(index[0].index);\n    var row = index[Math.floor(x + d)];\n\n    if (row !== undefined) {\n      var date = row.date;\n      return date;\n    }\n  };\n\n  scale.nice = function (count) {\n    backingLinearScale.nice(count);\n    return scale;\n  };\n\n  scale.index = function (x) {\n    if (x === undefined) {\n      return index;\n    }\n\n    index = x;\n    return scale;\n  };\n\n  scale.copy = function () {\n    return financeDiscontinuousScale(index, backingLinearScale.copy());\n  };\n\n  return scale;\n}","map":null,"metadata":{},"sourceType":"module"}