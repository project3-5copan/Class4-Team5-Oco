{"ast":null,"code":"import _classCallCheck from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from \"react\";\nimport { isDefined, isNotDefined, noop } from \"@react-financial-charts/core\";\nimport { HoverTextNearMouse, MouseLocationIndicator } from \"./components\";\nimport { isHoverForInteractiveType, saveNodeType, terminate } from \"./utils\";\nimport { EachFibRetracement } from \"./wrapper\";\nexport var FibonacciRetracement = /*#__PURE__*/function (_React$Component) {\n  _inherits(FibonacciRetracement, _React$Component);\n\n  var _super = _createSuper(FibonacciRetracement);\n\n  function FibonacciRetracement(props) {\n    var _this;\n\n    _classCallCheck(this, FibonacciRetracement);\n\n    _this = _super.call(this, props);\n\n    _this.handleDrawRetracement = function (_, xyValue) {\n      var current = _this.state.current;\n\n      if (isDefined(current) && isDefined(current.x1)) {\n        _this.mouseMoved = true;\n\n        _this.setState({\n          current: Object.assign(Object.assign({}, current), {\n            x2: xyValue[0],\n            y2: xyValue[1]\n          })\n        });\n      }\n    };\n\n    _this.handleEdge1Drag = function (_, echo, newXYValue, origXYValue) {\n      var retracements = _this.props.retracements;\n      var index = echo.index;\n      var dx = origXYValue.x1Value - newXYValue.x1Value;\n\n      _this.setState({\n        override: {\n          index: index,\n          x1: retracements[index].x1 - dx,\n          y1: retracements[index].y1,\n          x2: retracements[index].x2,\n          y2: retracements[index].y2\n        }\n      });\n    };\n\n    _this.handleDrag = function (_, index, xy) {\n      _this.setState({\n        override: Object.assign({\n          index: index\n        }, xy)\n      });\n    };\n\n    _this.handleEdge2Drag = function (_, echo, newXYValue, origXYValue) {\n      var retracements = _this.props.retracements;\n      var index = echo.index;\n      var dx = origXYValue.x2Value - newXYValue.x2Value;\n\n      _this.setState({\n        override: {\n          index: index,\n          x1: retracements[index].x1,\n          y1: retracements[index].y1,\n          x2: retracements[index].x2 - dx,\n          y2: retracements[index].y2\n        }\n      });\n    };\n\n    _this.handleDragComplete = function (e, moreProps) {\n      var retracements = _this.props.retracements;\n      var override = _this.state.override;\n\n      if (isDefined(override)) {\n        var index = override.index,\n            rest = __rest(override, [\"index\"]);\n\n        var newRetracements = retracements.map(function (each, idx) {\n          return idx === index ? Object.assign(Object.assign(Object.assign({}, each), rest), {\n            selected: true\n          }) : each;\n        });\n\n        _this.setState({\n          override: null\n        }, function () {\n          var onComplete = _this.props.onComplete;\n\n          if (onComplete !== undefined) {\n            onComplete(e, newRetracements, moreProps);\n          }\n        });\n      }\n    };\n\n    _this.handleStart = function (e, xyValue, moreProps) {\n      var current = _this.state.current;\n\n      if (isNotDefined(current) || isNotDefined(current.x1)) {\n        _this.mouseMoved = false;\n\n        _this.setState({\n          current: {\n            x1: xyValue[0],\n            y1: xyValue[1],\n            x2: null,\n            y2: null\n          }\n        }, function () {\n          var onStart = _this.props.onStart;\n\n          if (onStart !== undefined) {\n            onStart(moreProps);\n          }\n        });\n      }\n    };\n\n    _this.handleEnd = function (e, xyValue, moreProps) {\n      var _this$props = _this.props,\n          retracements = _this$props.retracements,\n          appearance = _this$props.appearance,\n          type = _this$props.type;\n      var current = _this.state.current;\n\n      if (_this.mouseMoved && isDefined(current) && isDefined(current.x1)) {\n        var newRetracements = retracements.concat(Object.assign(Object.assign({}, current), {\n          x2: xyValue[0],\n          y2: xyValue[1],\n          selected: true,\n          appearance: appearance,\n          type: type\n        }));\n\n        _this.setState({\n          current: null\n        }, function () {\n          var onComplete = _this.props.onComplete;\n\n          if (onComplete !== undefined) {\n            onComplete(e, newRetracements, moreProps);\n          }\n        });\n      }\n    };\n\n    _this.handleEdge1Drag = _this.handleEdge1Drag.bind(_assertThisInitialized(_this));\n    _this.handleEdge2Drag = _this.handleEdge2Drag.bind(_assertThisInitialized(_this));\n    _this.terminate = terminate.bind(_assertThisInitialized(_this));\n    _this.getSelectionState = isHoverForInteractiveType(\"retracements\").bind(_assertThisInitialized(_this));\n    _this.saveNodeType = saveNodeType.bind(_assertThisInitialized(_this));\n    _this.state = {};\n    return _this;\n  }\n\n  _createClass(FibonacciRetracement, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$state = this.state,\n          current = _this$state.current,\n          override = _this$state.override;\n      var _this$props2 = this.props,\n          appearance = _this$props2.appearance,\n          currentPositionStroke = _this$props2.currentPositionStroke,\n          currentPositionOpacity = _this$props2.currentPositionOpacity,\n          currentPositionStrokeWidth = _this$props2.currentPositionStrokeWidth,\n          _this$props2$currentP = _this$props2.currentPositionRadius,\n          currentPositionRadius = _this$props2$currentP === void 0 ? FibonacciRetracement.defaultProps.currentPositionRadius : _this$props2$currentP,\n          retracements = _this$props2.retracements,\n          type = _this$props2.type;\n      var _this$props3 = this.props,\n          enabled = _this$props3.enabled,\n          hoverText = _this$props3.hoverText;\n      var overrideIndex = isDefined(override) ? override.index : null;\n      var hoverTextWidthDefault = Object.assign(Object.assign({}, FibonacciRetracement.defaultProps.hoverText), hoverText);\n      var currentRetracement = isDefined(current) && isDefined(current.x2) ? React.createElement(EachFibRetracement, Object.assign({\n        interactive: false,\n        type: type,\n        appearance: appearance,\n        hoverText: hoverTextWidthDefault\n      }, current)) : null;\n      return React.createElement(\"g\", null, retracements.map(function (each, idx) {\n        var eachAppearance = isDefined(each.appearance) ? Object.assign(Object.assign({}, appearance), each.appearance) : appearance;\n        var eachHoverText = isDefined(each.hoverText) ? Object.assign(Object.assign({}, hoverTextWidthDefault), each.hoverText) : hoverTextWidthDefault;\n        return React.createElement(EachFibRetracement, Object.assign({\n          key: idx,\n          ref: _this2.saveNodeType(idx),\n          index: idx,\n          type: each.type,\n          selected: each.selected\n        }, idx === overrideIndex ? override : each, {\n          hoverText: eachHoverText,\n          appearance: eachAppearance,\n          onDrag: _this2.handleDrag,\n          onDragComplete: _this2.handleDragComplete\n        }));\n      }), currentRetracement, React.createElement(MouseLocationIndicator, {\n        enabled: enabled,\n        snap: false,\n        r: currentPositionRadius,\n        stroke: currentPositionStroke,\n        opacity: currentPositionOpacity,\n        strokeWidth: currentPositionStrokeWidth,\n        onMouseDown: this.handleStart,\n        onClick: this.handleEnd,\n        onMouseMove: this.handleDrawRetracement\n      }));\n    }\n  }]);\n\n  return FibonacciRetracement;\n}(React.Component);\nFibonacciRetracement.defaultProps = {\n  enabled: true,\n  type: \"RAY\",\n  retracements: [],\n  onSelect: noop,\n  hoverText: Object.assign(Object.assign({}, HoverTextNearMouse.defaultProps), {\n    enable: true,\n    bgHeight: \"auto\",\n    bgWidth: \"auto\",\n    text: \"Click to select object\",\n    selectedText: \"\"\n  }),\n  currentPositionStroke: \"#000000\",\n  currentPositionOpacity: 1,\n  currentPositionStrokeWidth: 3,\n  currentPositionRadius: 4,\n  appearance: {\n    stroke: \"#000000\",\n    strokeWidth: 1,\n    strokeOpacity: 1,\n    fontFamily: \"-apple-system, system-ui, Roboto, 'Helvetica Neue', Ubuntu, sans-serif\",\n    fontSize: 11,\n    fontFill: \"#000000\",\n    edgeStroke: \"#000000\",\n    edgeFill: \"#FFFFFF\",\n    nsEdgeFill: \"#000000\",\n    edgeStrokeWidth: 1,\n    r: 5\n  }\n};","map":null,"metadata":{},"sourceType":"module"}