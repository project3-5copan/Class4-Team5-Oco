{"ast":null,"code":"import _slicedToArray from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { getStrokeDasharrayCanvas, getMouseCanvas, GenericChartComponent, noop } from \"@react-financial-charts/core\";\nimport * as React from \"react\";\nexport var InteractiveStraightLine = /*#__PURE__*/function (_React$Component) {\n  _inherits(InteractiveStraightLine, _React$Component);\n\n  var _super = _createSuper(InteractiveStraightLine);\n\n  function InteractiveStraightLine() {\n    var _this;\n\n    _classCallCheck(this, InteractiveStraightLine);\n\n    _this = _super.apply(this, arguments);\n\n    _this.isHover = function (moreProps) {\n      var _this$props = _this.props,\n          tolerance = _this$props.tolerance,\n          onHover = _this$props.onHover;\n\n      if (onHover !== undefined) {\n        var _this$props2 = _this.props,\n            x1Value = _this$props2.x1Value,\n            x2Value = _this$props2.x2Value,\n            y1Value = _this$props2.y1Value,\n            y2Value = _this$props2.y2Value,\n            type = _this$props2.type;\n        var mouseXY = moreProps.mouseXY,\n            xScale = moreProps.xScale;\n        var yScale = moreProps.chartConfig.yScale;\n        var hovering = isHovering({\n          x1Value: x1Value,\n          y1Value: y1Value,\n          x2Value: x2Value,\n          y2Value: y2Value,\n          mouseXY: mouseXY,\n          type: type,\n          tolerance: tolerance,\n          xScale: xScale,\n          yScale: yScale\n        });\n        return hovering;\n      }\n\n      return false;\n    };\n\n    _this.drawOnCanvas = function (ctx, moreProps) {\n      var _this$props3 = _this.props,\n          _this$props3$strokeWi = _this$props3.strokeWidth,\n          strokeWidth = _this$props3$strokeWi === void 0 ? InteractiveStraightLine.defaultProps.strokeWidth : _this$props3$strokeWi,\n          strokeDasharray = _this$props3.strokeDasharray,\n          strokeStyle = _this$props3.strokeStyle;\n\n      var _helper = helper(_this.props, moreProps),\n          x1 = _helper.x1,\n          y1 = _helper.y1,\n          x2 = _helper.x2,\n          y2 = _helper.y2;\n\n      ctx.lineWidth = strokeWidth;\n      ctx.strokeStyle = strokeStyle;\n      var lineDash = getStrokeDasharrayCanvas(strokeDasharray);\n      ctx.setLineDash(lineDash);\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y2);\n      ctx.stroke();\n    };\n\n    return _this;\n  }\n\n  _createClass(InteractiveStraightLine, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props4 = this.props,\n          selected = _this$props4.selected,\n          interactiveCursorClass = _this$props4.interactiveCursorClass;\n      var _this$props5 = this.props,\n          onDragStart = _this$props5.onDragStart,\n          onDrag = _this$props5.onDrag,\n          onDragComplete = _this$props5.onDragComplete,\n          onHover = _this$props5.onHover,\n          onUnHover = _this$props5.onUnHover;\n      return React.createElement(GenericChartComponent, {\n        isHover: this.isHover,\n        canvasToDraw: getMouseCanvas,\n        canvasDraw: this.drawOnCanvas,\n        interactiveCursorClass: interactiveCursorClass,\n        selected: selected,\n        onDragStart: onDragStart,\n        onDrag: onDrag,\n        onDragComplete: onDragComplete,\n        onHover: onHover,\n        onUnHover: onUnHover,\n        drawOn: [\"mousemove\", \"pan\", \"drag\"]\n      });\n    }\n  }]);\n\n  return InteractiveStraightLine;\n}(React.Component);\nInteractiveStraightLine.defaultProps = {\n  onEdge1Drag: noop,\n  onEdge2Drag: noop,\n  edgeStrokeWidth: 3,\n  edgeStroke: \"#000000\",\n  edgeFill: \"#FFFFFF\",\n  r: 10,\n  withEdge: false,\n  strokeWidth: 1,\n  strokeDasharray: \"Solid\",\n  children: noop,\n  tolerance: 7,\n  selected: false\n};\nexport function isHovering2(start, end, _ref, tolerance) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      mouseX = _ref2[0],\n      mouseY = _ref2[1];\n\n  var m = getSlope(start, end);\n\n  if (m !== undefined) {\n    var b = getYIntercept(m, end);\n    var y = m * mouseX + b;\n    return mouseY < y + tolerance && mouseY > y - tolerance && mouseX > Math.min(start[0], end[0]) - tolerance && mouseX < Math.max(start[0], end[0]) + tolerance;\n  } else {\n    return mouseY >= Math.min(start[1], end[1]) && mouseY <= Math.max(start[1], end[1]) && mouseX < start[0] + tolerance && mouseX > start[0] - tolerance;\n  }\n}\nexport function isHovering(_ref3) {\n  var x1Value = _ref3.x1Value,\n      y1Value = _ref3.y1Value,\n      x2Value = _ref3.x2Value,\n      y2Value = _ref3.y2Value,\n      mouseXY = _ref3.mouseXY,\n      type = _ref3.type,\n      tolerance = _ref3.tolerance,\n      xScale = _ref3.xScale,\n      yScale = _ref3.yScale;\n  var line = generateLine({\n    type: type,\n    start: [x1Value, y1Value],\n    end: [x2Value, y2Value],\n    xScale: xScale,\n    yScale: yScale\n  });\n  var start = [xScale(line.x1), yScale(line.y1)];\n  var end = [xScale(line.x2), yScale(line.y2)];\n  var m = getSlope(start, end);\n\n  var _mouseXY = _slicedToArray(mouseXY, 2),\n      mouseX = _mouseXY[0],\n      mouseY = _mouseXY[1];\n\n  if (m !== undefined) {\n    var b = getYIntercept(m, end);\n    var y = m * mouseX + b;\n    return mouseY < y + tolerance && mouseY > y - tolerance && mouseX > Math.min(start[0], end[0]) - tolerance && mouseX < Math.max(start[0], end[0]) + tolerance;\n  } else {\n    return mouseY >= Math.min(start[1], end[1]) && mouseY <= Math.max(start[1], end[1]) && mouseX < start[0] + tolerance && mouseX > start[0] - tolerance;\n  }\n}\n\nfunction helper(props, moreProps) {\n  var x1Value = props.x1Value,\n      x2Value = props.x2Value,\n      y1Value = props.y1Value,\n      y2Value = props.y2Value,\n      type = props.type;\n  var xScale = moreProps.xScale,\n      yScale = moreProps.chartConfig.yScale;\n  var modLine = generateLine({\n    type: type,\n    start: [x1Value, y1Value],\n    end: [x2Value, y2Value],\n    xScale: xScale,\n    yScale: yScale\n  });\n  var x1 = xScale(modLine.x1);\n  var y1 = yScale(modLine.y1);\n  var x2 = xScale(modLine.x2);\n  var y2 = yScale(modLine.y2);\n  return {\n    x1: x1,\n    y1: y1,\n    x2: x2,\n    y2: y2\n  };\n}\n\nexport function getSlope(start, end) {\n  var m\n  /* slope */\n  = end[0] === start[0] ? undefined : (end[1] - start[1]) / (end[0] - start[0]);\n  return m;\n}\nexport function getYIntercept(m, end) {\n  var b\n  /* y intercept */\n  = -1 * m * end[0] + end[1];\n  return b;\n}\nexport function generateLine(_ref4) {\n  var type = _ref4.type,\n      start = _ref4.start,\n      end = _ref4.end,\n      xScale = _ref4.xScale,\n      yScale = _ref4.yScale;\n  var m\n  /* slope */\n  = getSlope(start, end);\n  var b\n  /* y intercept */\n  = getYIntercept(m, start);\n\n  switch (type) {\n    case \"XLINE\":\n      return getXLineCoordinates({\n        start: start,\n        end: end,\n        xScale: xScale,\n        yScale: yScale,\n        m: m,\n        b: b\n      });\n\n    case \"RAY\":\n      return getRayCoordinates({\n        start: start,\n        end: end,\n        xScale: xScale,\n        yScale: yScale,\n        m: m,\n        b: b\n      });\n\n    default:\n    case \"LINE\":\n      return getLineCoordinates({\n        start: start,\n        end: end\n      });\n  }\n}\n\nfunction getXLineCoordinates(_ref5) {\n  var start = _ref5.start,\n      end = _ref5.end,\n      xScale = _ref5.xScale,\n      yScale = _ref5.yScale,\n      m = _ref5.m,\n      b = _ref5.b;\n\n  var _xScale$domain = xScale.domain(),\n      _xScale$domain2 = _slicedToArray(_xScale$domain, 2),\n      xBegin = _xScale$domain2[0],\n      xFinish = _xScale$domain2[1];\n\n  var _yScale$domain = yScale.domain(),\n      _yScale$domain2 = _slicedToArray(_yScale$domain, 2),\n      yBegin = _yScale$domain2[0],\n      yFinish = _yScale$domain2[1];\n\n  if (end[0] === start[0]) {\n    return {\n      x1: end[0],\n      y1: yBegin,\n      x2: end[0],\n      y2: yFinish\n    };\n  }\n\n  var _ref6 = end[0] > start[0] ? [xBegin, xFinish] : [xFinish, xBegin],\n      _ref7 = _slicedToArray(_ref6, 2),\n      x1 = _ref7[0],\n      x2 = _ref7[1];\n\n  return {\n    x1: x1,\n    y1: m * x1 + b,\n    x2: x2,\n    y2: m * x2 + b\n  };\n}\n\nfunction getRayCoordinates(_ref8) {\n  var start = _ref8.start,\n      end = _ref8.end,\n      xScale = _ref8.xScale,\n      yScale = _ref8.yScale,\n      m = _ref8.m,\n      b = _ref8.b;\n\n  var _xScale$domain3 = xScale.domain(),\n      _xScale$domain4 = _slicedToArray(_xScale$domain3, 2),\n      xBegin = _xScale$domain4[0],\n      xFinish = _xScale$domain4[1];\n\n  var _yScale$domain3 = yScale.domain(),\n      _yScale$domain4 = _slicedToArray(_yScale$domain3, 2),\n      yBegin = _yScale$domain4[0],\n      yFinish = _yScale$domain4[1];\n\n  var x1 = start[0];\n\n  if (end[0] === start[0]) {\n    return {\n      x1: x1,\n      y1: start[1],\n      x2: x1,\n      y2: end[1] > start[1] ? yFinish : yBegin\n    };\n  }\n\n  var x2 = end[0] > start[0] ? xFinish : xBegin;\n  return {\n    x1: x1,\n    y1: m * x1 + b,\n    x2: x2,\n    y2: m * x2 + b\n  };\n}\n\nfunction getLineCoordinates(_ref9) {\n  var start = _ref9.start,\n      end = _ref9.end;\n\n  var _start = _slicedToArray(start, 2),\n      x1 = _start[0],\n      y1 = _start[1];\n\n  var _end = _slicedToArray(end, 2),\n      x2 = _end[0],\n      y2 = _end[1];\n\n  if (end[0] === start[0]) {\n    return {\n      x1: x1,\n      y1: start[1],\n      x2: x1,\n      y2: end[1]\n    };\n  }\n\n  return {\n    x1: x1,\n    y1: y1,\n    x2: x2,\n    y2: y2\n  };\n}","map":null,"metadata":{},"sourceType":"module"}