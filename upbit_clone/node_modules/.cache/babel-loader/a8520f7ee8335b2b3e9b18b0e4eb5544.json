{"ast":null,"code":"import _classCallCheck from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _slicedToArray from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { extent as d3Extent, max, min } from \"d3-array\";\nimport * as PropTypes from \"prop-types\";\nimport * as React from \"react\";\nimport { clearCanvas, functor, head, identity, isDefined, isNotDefined, last, shallowEqual } from \"./utils\";\nimport { mouseBasedZoomAnchor } from \"./zoom/zoomBehavior\";\nimport { getChartConfigWithUpdatedYScales, getCurrentCharts, getCurrentItem, getNewChartConfig } from \"./utils/ChartDataUtil\";\nimport { EventCapture } from \"./EventCapture\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport evaluator from \"./utils/evaluator\";\nvar CANDIDATES_FOR_RESET = [\"seriesName\"];\n\nvar shouldResetChart = function shouldResetChart(thisProps, nextProps) {\n  return !CANDIDATES_FOR_RESET.every(function (key) {\n    var result = shallowEqual(thisProps[key], nextProps[key]);\n    return result;\n  });\n};\n\nvar getCursorStyle = function getCursorStyle() {\n  var tooltipStyle = \"\\n\\t.react-financial-charts-grabbing-cursor {\\n\\t\\tpointer-events: all;\\n\\t\\tcursor: -moz-grabbing;\\n\\t\\tcursor: -webkit-grabbing;\\n\\t\\tcursor: grabbing;\\n\\t}\\n\\t.react-financial-charts-crosshair-cursor {\\n\\t\\tpointer-events: all;\\n\\t\\tcursor: crosshair;\\n\\t}\\n\\t.react-financial-charts-tooltip-hover {\\n\\t\\tpointer-events: all;\\n\\t\\tcursor: pointer;\\n\\t}\\n\\t.react-financial-charts-avoid-interaction {\\n\\t\\tpointer-events: none;\\n\\t}\\n\\t.react-financial-charts-enable-interaction {\\n\\t\\tpointer-events: all;\\n\\t}\\n\\t.react-financial-charts-tooltip {\\n\\t\\tpointer-events: all;\\n\\t\\tcursor: pointer;\\n\\t}\\n\\t.react-financial-charts-default-cursor {\\n\\t\\tcursor: default;\\n\\t}\\n\\t.react-financial-charts-move-cursor {\\n\\t\\tcursor: move;\\n\\t}\\n\\t.react-financial-charts-pointer-cursor {\\n\\t\\tcursor: pointer;\\n\\t}\\n\\t.react-financial-charts-ns-resize-cursor {\\n\\t\\tcursor: ns-resize;\\n\\t}\\n\\t.react-financial-charts-ew-resize-cursor {\\n\\t\\tcursor: ew-resize;\\n\\t}\";\n  return React.createElement(\"style\", {\n    type: \"text/css\"\n  }, tooltipStyle);\n};\n\nvar getDimensions = function getDimensions(props) {\n  var margin = props.margin,\n      height = props.height,\n      width = props.width;\n  return {\n    height: height - margin.top - margin.bottom,\n    width: width - margin.left - margin.right\n  };\n};\n\nvar getXScaleDirection = function getXScaleDirection(flipXScale) {\n  return flipXScale ? -1 : 1;\n};\n\nvar calculateFullData = function calculateFullData(props) {\n  var fullData = props.data,\n      plotFull = props.plotFull,\n      xScale = props.xScale,\n      clamp = props.clamp,\n      pointsPerPxThreshold = props.pointsPerPxThreshold,\n      flipXScale = props.flipXScale,\n      xAccessor = props.xAccessor,\n      displayXAccessor = props.displayXAccessor,\n      minPointsPerPxThreshold = props.minPointsPerPxThreshold;\n  var useWholeData = plotFull !== undefined ? plotFull : xAccessor === identity;\n\n  var _evaluator = evaluator({\n    xScale: xScale,\n    useWholeData: useWholeData,\n    clamp: clamp,\n    pointsPerPxThreshold: pointsPerPxThreshold,\n    minPointsPerPxThreshold: minPointsPerPxThreshold,\n    flipXScale: flipXScale\n  }),\n      filterData = _evaluator.filterData;\n\n  return {\n    xAccessor: xAccessor,\n    displayXAccessor: displayXAccessor !== null && displayXAccessor !== void 0 ? displayXAccessor : xAccessor,\n    xScale: xScale.copy(),\n    fullData: fullData,\n    filterData: filterData\n  };\n};\n\nvar resetChart = function resetChart(props) {\n  var state = calculateState(props);\n  var xAccessor = state.xAccessor,\n      displayXAccessor = state.displayXAccessor,\n      fullData = state.fullData,\n      initialPlotData = state.plotData,\n      xScale = state.xScale;\n  var postCalculator = props.postCalculator,\n      children = props.children;\n  var plotData = postCalculator !== undefined ? postCalculator(initialPlotData) : initialPlotData;\n  var dimensions = getDimensions(props);\n  var chartConfig = getChartConfigWithUpdatedYScales(getNewChartConfig(dimensions, children), {\n    plotData: plotData,\n    xAccessor: xAccessor,\n    displayXAccessor: displayXAccessor,\n    fullData: fullData\n  }, xScale.domain());\n  return Object.assign(Object.assign({}, state), {\n    xScale: xScale,\n    plotData: plotData,\n    chartConfig: chartConfig\n  });\n};\n\nvar updateChart = function updateChart(newState, initialXScale, props, lastItemWasVisible, initialChartConfig) {\n  var fullData = newState.fullData,\n      xScale = newState.xScale,\n      xAccessor = newState.xAccessor,\n      displayXAccessor = newState.displayXAccessor,\n      filterData = newState.filterData;\n  var lastItem = last(fullData);\n  var lastXItem = xAccessor(lastItem);\n\n  var _initialXScale$domain = initialXScale.domain(),\n      _initialXScale$domain2 = _slicedToArray(_initialXScale$domain, 2),\n      start = _initialXScale$domain2[0],\n      end = _initialXScale$domain2[1];\n\n  var postCalculator = props.postCalculator,\n      children = props.children,\n      padding = props.padding,\n      flipXScale = props.flipXScale,\n      maintainPointsPerPixelOnResize = props.maintainPointsPerPixelOnResize;\n  var direction = getXScaleDirection(flipXScale);\n  var dimensions = getDimensions(props);\n  var updatedXScale = setXRange(xScale, dimensions, padding, direction);\n  var initialPlotData;\n\n  if (!lastItemWasVisible || end >= lastXItem) {\n    // resize comes here...\n    // get plotData between [start, end] and do not change the domain\n    var _initialXScale$range = initialXScale.range(),\n        _initialXScale$range2 = _slicedToArray(_initialXScale$range, 2),\n        rangeStart = _initialXScale$range2[0],\n        rangeEnd = _initialXScale$range2[1];\n\n    var _updatedXScale$range = updatedXScale.range(),\n        _updatedXScale$range2 = _slicedToArray(_updatedXScale$range, 2),\n        newRangeStart = _updatedXScale$range2[0],\n        newRangeEnd = _updatedXScale$range2[1];\n\n    var newDomainExtent = (newRangeEnd - newRangeStart) / (rangeEnd - rangeStart) * (end.valueOf() - start.valueOf());\n    var newStart = maintainPointsPerPixelOnResize ? end.valueOf() - newDomainExtent : start;\n    var lastItemX = initialXScale(lastXItem);\n    var response = filterData(fullData, [newStart, end], xAccessor, updatedXScale, {\n      fallbackStart: start,\n      fallbackEnd: {\n        lastItem: lastItem,\n        lastItemX: lastItemX\n      }\n    });\n    initialPlotData = response.plotData;\n    updatedXScale.domain(response.domain);\n  } else if (lastItemWasVisible && end < lastXItem) {\n    // this is when a new item is added and last item was visible\n    // so slide over and show the new item also\n    // get plotData between [xAccessor(l) - (end - start), xAccessor(l)] and DO change the domain\n    var dx = initialXScale(lastXItem) - initialXScale.range()[1];\n\n    var _initialXScale$range$ = initialXScale.range().map(function (x) {\n      return x + dx;\n    }).map(function (x) {\n      return initialXScale.invert(x);\n    }),\n        _initialXScale$range$2 = _slicedToArray(_initialXScale$range$, 2),\n        _newStart = _initialXScale$range$2[0],\n        newEnd = _initialXScale$range$2[1];\n\n    var _response = filterData(fullData, [_newStart, newEnd], xAccessor, updatedXScale);\n\n    initialPlotData = _response.plotData;\n    updatedXScale.domain(_response.domain); // if last item was visible, then shift\n  }\n\n  var plotData = postCalculator(initialPlotData);\n  var chartConfig = getChartConfigWithUpdatedYScales(getNewChartConfig(dimensions, children, initialChartConfig), {\n    plotData: plotData,\n    xAccessor: xAccessor,\n    displayXAccessor: displayXAccessor,\n    fullData: fullData\n  }, updatedXScale.domain());\n  return {\n    xScale: updatedXScale,\n    xAccessor: xAccessor,\n    chartConfig: chartConfig,\n    plotData: plotData,\n    fullData: fullData,\n    filterData: filterData\n  };\n};\n\nvar calculateState = function calculateState(props) {\n  var inputXAccesor = props.xAccessor,\n      xExtentsProp = props.xExtents,\n      data = props.data,\n      padding = props.padding,\n      flipXScale = props.flipXScale;\n  var direction = getXScaleDirection(flipXScale);\n  var dimensions = getDimensions(props);\n  var extent = typeof xExtentsProp === \"function\" ? xExtentsProp(data) : d3Extent(xExtentsProp.map(function (d) {\n    return functor(d);\n  }).map(function (each) {\n    return each(data, inputXAccesor);\n  }));\n\n  var _calculateFullData = calculateFullData(props),\n      xAccessor = _calculateFullData.xAccessor,\n      displayXAccessor = _calculateFullData.displayXAccessor,\n      xScale = _calculateFullData.xScale,\n      fullData = _calculateFullData.fullData,\n      filterData = _calculateFullData.filterData;\n\n  var updatedXScale = setXRange(xScale, dimensions, padding, direction);\n\n  var _filterData = filterData(fullData, extent, inputXAccesor, updatedXScale),\n      plotData = _filterData.plotData,\n      domain = _filterData.domain;\n\n  return {\n    plotData: plotData,\n    xScale: updatedXScale.domain(domain),\n    xAccessor: xAccessor,\n    displayXAccessor: displayXAccessor,\n    fullData: fullData,\n    filterData: filterData\n  };\n};\n\nvar setXRange = function setXRange(xScale, dimensions, padding) {\n  var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n  if (xScale.rangeRoundPoints) {\n    if (isNaN(padding)) {\n      throw new Error(\"padding has to be a number for ordinal scale\");\n    }\n\n    xScale.rangeRoundPoints([0, dimensions.width], padding);\n  } else if (xScale.padding) {\n    if (isNaN(padding)) {\n      throw new Error(\"padding has to be a number for ordinal scale\");\n    }\n\n    xScale.range([0, dimensions.width]);\n    xScale.padding(padding / 2);\n  } else {\n    var _ref = isNaN(padding) ? padding : {\n      left: padding,\n      right: padding\n    },\n        left = _ref.left,\n        right = _ref.right;\n\n    if (direction > 0) {\n      xScale.range([left, dimensions.width - right]);\n    } else {\n      xScale.range([dimensions.width - right, left]);\n    }\n  }\n\n  return xScale;\n};\n\nvar pinchCoordinates = function pinchCoordinates(pinch) {\n  var touch1Pos = pinch.touch1Pos,\n      touch2Pos = pinch.touch2Pos;\n  return {\n    topLeft: [Math.min(touch1Pos[0], touch2Pos[0]), Math.min(touch1Pos[1], touch2Pos[1])],\n    bottomRight: [Math.max(touch1Pos[0], touch2Pos[0]), Math.max(touch1Pos[1], touch2Pos[1])]\n  };\n};\n\nvar isInteractionEnabled = function isInteractionEnabled(xScale, xAccessor, data) {\n  var interaction = !isNaN(xScale(xAccessor(head(data)))) && isDefined(xScale.invert);\n  return interaction;\n};\n\nexport var ChartCanvas = /*#__PURE__*/function (_React$Component) {\n  _inherits(ChartCanvas, _React$Component);\n\n  var _super = _createSuper(ChartCanvas);\n\n  function ChartCanvas(props) {\n    var _this;\n\n    _classCallCheck(this, ChartCanvas);\n\n    _this = _super.call(this, props);\n    _this.canvasContainerRef = React.createRef();\n    _this.eventCaptureRef = React.createRef();\n    _this.lastSubscriptionId = 0;\n    _this.mutableState = {};\n    _this.panInProgress = false;\n    _this.subscriptions = [];\n\n    _this.getMutableState = function () {\n      return _this.mutableState;\n    };\n\n    _this.getDataInfo = function () {\n      return Object.assign(Object.assign({}, _this.state), {\n        fullData: _this.fullData\n      });\n    };\n\n    _this.getCanvasContexts = function () {\n      var _a;\n\n      return (_a = _this.canvasContainerRef.current) === null || _a === void 0 ? void 0 : _a.getCanvasContexts();\n    };\n\n    _this.generateSubscriptionId = function () {\n      _this.lastSubscriptionId++;\n      return _this.lastSubscriptionId;\n    };\n\n    _this.subscribe = function (id, rest) {\n      var _rest$getPanCondition = rest.getPanConditions,\n          getPanConditions = _rest$getPanCondition === void 0 ? functor({\n        draggable: false,\n        panEnabled: true\n      }) : _rest$getPanCondition;\n      _this.subscriptions = _this.subscriptions.concat(Object.assign(Object.assign({\n        id: id\n      }, rest), {\n        getPanConditions: getPanConditions\n      }));\n    };\n\n    _this.unsubscribe = function (id) {\n      _this.subscriptions = _this.subscriptions.filter(function (each) {\n        return each.id !== id;\n      });\n    };\n\n    _this.getAllPanConditions = function () {\n      return _this.subscriptions.map(function (each) {\n        return each.getPanConditions();\n      });\n    };\n\n    _this.setCursorClass = function (className) {\n      var _a;\n\n      (_a = _this.eventCaptureRef.current) === null || _a === void 0 ? void 0 : _a.setCursorClass(className);\n    };\n\n    _this.amIOnTop = function (id) {\n      var dragableComponents = _this.subscriptions.filter(function (each) {\n        return each.getPanConditions().draggable;\n      });\n\n      return dragableComponents.length > 0 && last(dragableComponents).id === id;\n    };\n\n    _this.handleContextMenu = function (mouseXY, e) {\n      var _this$state = _this.state,\n          xAccessor = _this$state.xAccessor,\n          chartConfig = _this$state.chartConfig,\n          plotData = _this$state.plotData,\n          xScale = _this$state.xScale;\n      var currentCharts = getCurrentCharts(chartConfig, mouseXY);\n      var currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n\n      _this.triggerEvent(\"contextmenu\", {\n        mouseXY: mouseXY,\n        currentItem: currentItem,\n        currentCharts: currentCharts\n      }, e);\n    };\n\n    _this.calculateStateForDomain = function (newDomain) {\n      var _this$state2 = _this.state,\n          xAccessor = _this$state2.xAccessor,\n          displayXAccessor = _this$state2.displayXAccessor,\n          initialXScale = _this$state2.xScale,\n          initialChartConfig = _this$state2.chartConfig,\n          initialPlotData = _this$state2.plotData;\n      var filterData = _this.state.filterData;\n\n      var _assertThisInitialize = _assertThisInitialized(_this),\n          fullData = _assertThisInitialize.fullData;\n\n      var _this$props$postCalcu = _this.props.postCalculator,\n          postCalculator = _this$props$postCalcu === void 0 ? ChartCanvas.defaultProps.postCalculator : _this$props$postCalcu;\n\n      var _filterData2 = filterData(fullData, newDomain, xAccessor, initialXScale, {\n        currentPlotData: initialPlotData,\n        currentDomain: initialXScale.domain()\n      }),\n          beforePlotData = _filterData2.plotData,\n          domain = _filterData2.domain;\n\n      var plotData = postCalculator(beforePlotData);\n      var updatedScale = initialXScale.copy().domain(domain);\n      var chartConfig = getChartConfigWithUpdatedYScales(initialChartConfig, {\n        plotData: plotData,\n        xAccessor: xAccessor,\n        displayXAccessor: displayXAccessor,\n        fullData: fullData\n      }, updatedScale.domain());\n      return {\n        xScale: updatedScale,\n        plotData: plotData,\n        chartConfig: chartConfig\n      };\n    };\n\n    _this.pinchZoomHelper = function (initialPinch, finalPinch) {\n      var initialPinchXScale = initialPinch.xScale;\n      var _this$state3 = _this.state,\n          initialXScale = _this$state3.xScale,\n          initialChartConfig = _this$state3.chartConfig,\n          initialPlotData = _this$state3.plotData,\n          xAccessor = _this$state3.xAccessor,\n          displayXAccessor = _this$state3.displayXAccessor,\n          filterData = _this$state3.filterData;\n\n      var _assertThisInitialize2 = _assertThisInitialized(_this),\n          fullData = _assertThisInitialize2.fullData;\n\n      var _this$props$postCalcu2 = _this.props.postCalculator,\n          postCalculator = _this$props$postCalcu2 === void 0 ? ChartCanvas.defaultProps.postCalculator : _this$props$postCalcu2;\n\n      var _pinchCoordinates = pinchCoordinates(initialPinch),\n          iTL = _pinchCoordinates.topLeft,\n          iBR = _pinchCoordinates.bottomRight;\n\n      var _pinchCoordinates2 = pinchCoordinates(finalPinch),\n          fTL = _pinchCoordinates2.topLeft,\n          fBR = _pinchCoordinates2.bottomRight;\n\n      var e = initialPinchXScale.range()[1];\n      var xDash = Math.round(-(iBR[0] * fTL[0] - iTL[0] * fBR[0]) / (iTL[0] - iBR[0]));\n      var yDash = Math.round(e + ((e - iBR[0]) * (e - fTL[0]) - (e - iTL[0]) * (e - fBR[0])) / (e - iTL[0] - (e - iBR[0])));\n      var x = Math.round(-xDash * iTL[0] / (-xDash + fTL[0]));\n      var y = Math.round(e - (yDash - e) * (e - iTL[0]) / (yDash + (e - fTL[0])));\n      var newDomain = [x, y].map(initialPinchXScale.invert);\n\n      var _filterData3 = filterData(fullData, newDomain, xAccessor, initialPinchXScale, {\n        currentPlotData: initialPlotData,\n        currentDomain: initialXScale.domain()\n      }),\n          beforePlotData = _filterData3.plotData,\n          domain = _filterData3.domain;\n\n      var plotData = postCalculator(beforePlotData);\n      var updatedScale = initialXScale.copy().domain(domain);\n      var mouseXY = finalPinch.touch1Pos;\n      var chartConfig = getChartConfigWithUpdatedYScales(initialChartConfig, {\n        plotData: plotData,\n        xAccessor: xAccessor,\n        displayXAccessor: displayXAccessor,\n        fullData: fullData\n      }, updatedScale.domain());\n      var currentItem = getCurrentItem(updatedScale, xAccessor, mouseXY, plotData);\n      return {\n        chartConfig: chartConfig,\n        xScale: updatedScale,\n        plotData: plotData,\n        mouseXY: mouseXY,\n        currentItem: currentItem\n      };\n    };\n\n    _this.handlePinchZoom = function (initialPinch, finalPinch, e) {\n      if (!_this.waitingForPinchZoomAnimationFrame) {\n        _this.waitingForPinchZoomAnimationFrame = true;\n\n        var _state = _this.pinchZoomHelper(initialPinch, finalPinch);\n\n        _this.triggerEvent(\"pinchzoom\", _state, e);\n\n        _this.finalPinch = finalPinch;\n        requestAnimationFrame(function () {\n          _this.clearBothCanvas();\n\n          _this.draw({\n            trigger: \"pinchzoom\"\n          });\n\n          _this.waitingForPinchZoomAnimationFrame = false;\n        });\n      }\n    };\n\n    _this.handlePinchZoomEnd = function (initialPinch, e) {\n      var _this$state$xAccessor = _this.state.xAccessor,\n          xAccessor = _this$state$xAccessor === void 0 ? ChartCanvas.defaultProps.xAccessor : _this$state$xAccessor;\n\n      if (_this.finalPinch) {\n        var _state2 = _this.pinchZoomHelper(initialPinch, _this.finalPinch);\n\n        var xScale = _state2.xScale;\n\n        _this.triggerEvent(\"pinchzoom\", _state2, e);\n\n        _this.finalPinch = undefined;\n\n        _this.clearThreeCanvas();\n\n        var _assertThisInitialize3 = _assertThisInitialized(_this),\n            _fullData = _assertThisInitialize3.fullData;\n\n        var firstItem = head(_fullData);\n        var scale_start = head(xScale.domain());\n        var data_start = xAccessor(firstItem);\n        var lastItem = last(_fullData);\n        var scale_end = last(xScale.domain());\n        var data_end = xAccessor(lastItem);\n        var _this$props = _this.props,\n            onLoadAfter = _this$props.onLoadAfter,\n            onLoadBefore = _this$props.onLoadBefore;\n\n        _this.setState(_state2, function () {\n          if (scale_start < data_start) {\n            if (onLoadBefore !== undefined) {\n              onLoadBefore(scale_start, data_start);\n            }\n          }\n\n          if (data_end < scale_end) {\n            if (onLoadAfter !== undefined) {\n              onLoadAfter(data_end, scale_end);\n            }\n          }\n        });\n      }\n    };\n\n    _this.handleZoom = function (zoomDirection, mouseXY, e) {\n      if (_this.panInProgress) {\n        return;\n      }\n\n      var _this$state4 = _this.state,\n          xAccessor = _this$state4.xAccessor,\n          initialXScale = _this$state4.xScale,\n          initialPlotData = _this$state4.plotData;\n      var _this$props2 = _this.props,\n          _this$props2$zoomMult = _this$props2.zoomMultiplier,\n          zoomMultiplier = _this$props2$zoomMult === void 0 ? ChartCanvas.defaultProps.zoomMultiplier : _this$props2$zoomMult,\n          _this$props2$zoomAnch = _this$props2.zoomAnchor,\n          zoomAnchor = _this$props2$zoomAnch === void 0 ? ChartCanvas.defaultProps.zoomAnchor : _this$props2$zoomAnch;\n\n      var _assertThisInitialize4 = _assertThisInitialized(_this),\n          fullData = _assertThisInitialize4.fullData;\n\n      var item = zoomAnchor({\n        xScale: initialXScale,\n        xAccessor: xAccessor,\n        mouseXY: mouseXY,\n        plotData: initialPlotData\n      });\n      var cx = initialXScale(item);\n      var c = zoomDirection > 0 ? 1 * zoomMultiplier : 1 / zoomMultiplier;\n      var newDomain = initialXScale.range().map(function (x) {\n        return cx + (x - cx) * c;\n      }).map(function (x) {\n        return initialXScale.invert(x);\n      });\n\n      var _this$calculateStateF = _this.calculateStateForDomain(newDomain),\n          xScale = _this$calculateStateF.xScale,\n          plotData = _this$calculateStateF.plotData,\n          chartConfig = _this$calculateStateF.chartConfig;\n\n      var currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n      var currentCharts = getCurrentCharts(chartConfig, mouseXY);\n\n      _this.clearThreeCanvas();\n\n      var firstItem = head(fullData);\n      var scale_start = head(xScale.domain());\n      var data_start = xAccessor(firstItem);\n      var lastItem = last(fullData);\n      var scale_end = last(xScale.domain());\n      var data_end = xAccessor(lastItem);\n      _this.mutableState = {\n        mouseXY: mouseXY,\n        currentItem: currentItem,\n        currentCharts: currentCharts\n      };\n\n      _this.triggerEvent(\"zoom\", {\n        xScale: xScale,\n        plotData: plotData,\n        chartConfig: chartConfig,\n        mouseXY: mouseXY,\n        currentCharts: currentCharts,\n        currentItem: currentItem,\n        show: true\n      }, e);\n\n      var _this$props3 = _this.props,\n          onLoadAfter = _this$props3.onLoadAfter,\n          onLoadBefore = _this$props3.onLoadBefore;\n\n      _this.setState({\n        xScale: xScale,\n        plotData: plotData,\n        chartConfig: chartConfig\n      }, function () {\n        if (scale_start < data_start) {\n          if (onLoadBefore !== undefined) {\n            onLoadBefore(scale_start, data_start);\n          }\n        }\n\n        if (data_end < scale_end) {\n          if (onLoadAfter !== undefined) {\n            onLoadAfter(data_end, scale_end);\n          }\n        }\n      });\n    };\n\n    _this.xAxisZoom = function (newDomain) {\n      var _this$calculateStateF2 = _this.calculateStateForDomain(newDomain),\n          xScale = _this$calculateStateF2.xScale,\n          plotData = _this$calculateStateF2.plotData,\n          chartConfig = _this$calculateStateF2.chartConfig;\n\n      _this.clearThreeCanvas();\n\n      var xAccessor = _this.state.xAccessor;\n\n      var _assertThisInitialize5 = _assertThisInitialized(_this),\n          fullData = _assertThisInitialize5.fullData;\n\n      var firstItem = head(fullData);\n      var scale_start = head(xScale.domain());\n      var data_start = xAccessor(firstItem);\n      var lastItem = last(fullData);\n      var scale_end = last(xScale.domain());\n      var data_end = xAccessor(lastItem);\n      var _this$props4 = _this.props,\n          onLoadAfter = _this$props4.onLoadAfter,\n          onLoadBefore = _this$props4.onLoadBefore;\n\n      _this.setState({\n        xScale: xScale,\n        plotData: plotData,\n        chartConfig: chartConfig\n      }, function () {\n        if (scale_start < data_start) {\n          if (onLoadBefore !== undefined) {\n            onLoadBefore(scale_start, data_start);\n          }\n        }\n\n        if (data_end < scale_end) {\n          if (onLoadAfter !== undefined) {\n            onLoadAfter(data_end, scale_end);\n          }\n        }\n      });\n    };\n\n    _this.yAxisZoom = function (chartId, newDomain) {\n      _this.clearThreeCanvas();\n\n      var initialChartConfig = _this.state.chartConfig;\n      var chartConfig = initialChartConfig.map(function (each) {\n        if (each.id === chartId) {\n          var yScale = each.yScale;\n          return Object.assign(Object.assign({}, each), {\n            yScale: yScale.copy().domain(newDomain),\n            yPanEnabled: true\n          });\n        } else {\n          return each;\n        }\n      });\n\n      _this.setState({\n        chartConfig: chartConfig\n      });\n    };\n\n    _this.draw = function (props) {\n      _this.subscriptions.forEach(function (each) {\n        if (isDefined(each.draw)) {\n          each.draw(props);\n        }\n      });\n    };\n\n    _this.redraw = function () {\n      _this.clearThreeCanvas();\n\n      _this.draw({\n        force: true\n      });\n    };\n\n    _this.panHelper = function (mouseXY, initialXScale, _ref2, chartsToPan) {\n      var dx = _ref2.dx,\n          dy = _ref2.dy;\n      var _this$state5 = _this.state,\n          xAccessor = _this$state5.xAccessor,\n          displayXAccessor = _this$state5.displayXAccessor,\n          initialChartConfig = _this$state5.chartConfig,\n          filterData = _this$state5.filterData;\n\n      var _assertThisInitialize6 = _assertThisInitialized(_this),\n          fullData = _assertThisInitialize6.fullData;\n\n      var _this$props$postCalcu3 = _this.props.postCalculator,\n          postCalculator = _this$props$postCalcu3 === void 0 ? ChartCanvas.defaultProps.postCalculator : _this$props$postCalcu3;\n      var newDomain = initialXScale.range().map(function (x) {\n        return x - dx;\n      }).map(function (x) {\n        return initialXScale.invert(x);\n      });\n\n      var _filterData4 = filterData(fullData, newDomain, xAccessor, initialXScale, {\n        currentPlotData: _this.hackyWayToStopPanBeyondBounds__plotData,\n        currentDomain: _this.hackyWayToStopPanBeyondBounds__domain,\n        ignoreThresholds: true\n      }),\n          beforePlotData = _filterData4.plotData,\n          domain = _filterData4.domain;\n\n      var updatedScale = initialXScale.copy().domain(domain);\n      var plotData = postCalculator(beforePlotData);\n      var currentItem = getCurrentItem(updatedScale, xAccessor, mouseXY, plotData);\n      var chartConfig = getChartConfigWithUpdatedYScales(initialChartConfig, {\n        plotData: plotData,\n        xAccessor: xAccessor,\n        displayXAccessor: displayXAccessor,\n        fullData: fullData\n      }, updatedScale.domain(), dy, chartsToPan);\n      var currentCharts = getCurrentCharts(chartConfig, mouseXY);\n      return {\n        xScale: updatedScale,\n        plotData: plotData,\n        chartConfig: chartConfig,\n        mouseXY: mouseXY,\n        currentCharts: currentCharts,\n        currentItem: currentItem\n      };\n    };\n\n    _this.handlePan = function (mousePosition, panStartXScale, dxdy, chartsToPan, e) {\n      var _a, _b;\n\n      if (!_this.waitingForPanAnimationFrame) {\n        _this.waitingForPanAnimationFrame = true;\n        _this.hackyWayToStopPanBeyondBounds__plotData = (_a = _this.hackyWayToStopPanBeyondBounds__plotData) !== null && _a !== void 0 ? _a : _this.state.plotData;\n        _this.hackyWayToStopPanBeyondBounds__domain = (_b = _this.hackyWayToStopPanBeyondBounds__domain) !== null && _b !== void 0 ? _b : _this.state.xScale.domain();\n\n        var newState = _this.panHelper(mousePosition, panStartXScale, dxdy, chartsToPan);\n\n        _this.hackyWayToStopPanBeyondBounds__plotData = newState.plotData;\n        _this.hackyWayToStopPanBeyondBounds__domain = newState.xScale.domain();\n        _this.panInProgress = true;\n\n        _this.triggerEvent(\"pan\", newState, e);\n\n        _this.mutableState = {\n          mouseXY: newState.mouseXY,\n          currentItem: newState.currentItem,\n          currentCharts: newState.currentCharts\n        };\n        requestAnimationFrame(function () {\n          _this.waitingForPanAnimationFrame = false;\n\n          _this.clearBothCanvas();\n\n          _this.draw({\n            trigger: \"pan\"\n          });\n        });\n      }\n    };\n\n    _this.handlePanEnd = function (mousePosition, panStartXScale, dxdy, chartsToPan, e) {\n      var state = _this.panHelper(mousePosition, panStartXScale, dxdy, chartsToPan);\n\n      _this.hackyWayToStopPanBeyondBounds__plotData = null;\n      _this.hackyWayToStopPanBeyondBounds__domain = null;\n      _this.panInProgress = false;\n      var xScale = state.xScale,\n          plotData = state.plotData,\n          chartConfig = state.chartConfig;\n\n      _this.triggerEvent(\"panend\", state, e);\n\n      requestAnimationFrame(function () {\n        var xAccessor = _this.state.xAccessor;\n\n        var _assertThisInitialize7 = _assertThisInitialized(_this),\n            fullData = _assertThisInitialize7.fullData;\n\n        var firstItem = head(fullData);\n        var scale_start = head(xScale.domain());\n        var data_start = xAccessor(firstItem);\n        var lastItem = last(fullData);\n        var scale_end = last(xScale.domain());\n        var data_end = xAccessor(lastItem);\n        var _this$props5 = _this.props,\n            onLoadAfter = _this$props5.onLoadAfter,\n            onLoadBefore = _this$props5.onLoadBefore;\n\n        _this.clearThreeCanvas();\n\n        _this.setState({\n          xScale: xScale,\n          plotData: plotData,\n          chartConfig: chartConfig\n        }, function () {\n          if (scale_start < data_start) {\n            if (onLoadBefore !== undefined) {\n              onLoadBefore(scale_start, data_start);\n            }\n          }\n\n          if (data_end < scale_end) {\n            if (onLoadAfter !== undefined) {\n              onLoadAfter(data_end, scale_end);\n            }\n          }\n        });\n      });\n    };\n\n    _this.handleMouseDown = function (_, __, e) {\n      _this.triggerEvent(\"mousedown\", _this.mutableState, e);\n    };\n\n    _this.handleMouseEnter = function (e) {\n      _this.triggerEvent(\"mouseenter\", {\n        show: true\n      }, e);\n    };\n\n    _this.handleMouseMove = function (mouseXY, _, e) {\n      if (!_this.waitingForMouseMoveAnimationFrame) {\n        _this.waitingForMouseMoveAnimationFrame = true;\n        var _this$state6 = _this.state,\n            chartConfig = _this$state6.chartConfig,\n            plotData = _this$state6.plotData,\n            xScale = _this$state6.xScale,\n            xAccessor = _this$state6.xAccessor;\n        var currentCharts = getCurrentCharts(chartConfig, mouseXY);\n        var currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n\n        _this.triggerEvent(\"mousemove\", {\n          show: true,\n          mouseXY: mouseXY,\n          // prevMouseXY is used in interactive components\n          prevMouseXY: _this.prevMouseXY,\n          currentItem: currentItem,\n          currentCharts: currentCharts\n        }, e);\n\n        _this.prevMouseXY = mouseXY;\n        _this.mutableState = {\n          mouseXY: mouseXY,\n          currentItem: currentItem,\n          currentCharts: currentCharts\n        };\n        requestAnimationFrame(function () {\n          _this.clearMouseCanvas();\n\n          _this.draw({\n            trigger: \"mousemove\"\n          });\n\n          _this.waitingForMouseMoveAnimationFrame = false;\n        });\n      }\n    };\n\n    _this.handleMouseLeave = function (e) {\n      _this.triggerEvent(\"mouseleave\", {\n        show: false\n      }, e);\n\n      _this.clearMouseCanvas();\n\n      _this.draw({\n        trigger: \"mouseleave\"\n      });\n    };\n\n    _this.handleDragStart = function (_ref3, e) {\n      var startPos = _ref3.startPos;\n\n      _this.triggerEvent(\"dragstart\", {\n        startPos: startPos\n      }, e);\n    };\n\n    _this.handleDrag = function (_ref4, e) {\n      var startPos = _ref4.startPos,\n          mouseXY = _ref4.mouseXY;\n      var _this$state7 = _this.state,\n          chartConfig = _this$state7.chartConfig,\n          plotData = _this$state7.plotData,\n          xScale = _this$state7.xScale,\n          xAccessor = _this$state7.xAccessor;\n      var currentCharts = getCurrentCharts(chartConfig, mouseXY);\n      var currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n\n      _this.triggerEvent(\"drag\", {\n        startPos: startPos,\n        mouseXY: mouseXY,\n        currentItem: currentItem,\n        currentCharts: currentCharts\n      }, e);\n\n      _this.mutableState = {\n        mouseXY: mouseXY,\n        currentItem: currentItem,\n        currentCharts: currentCharts\n      };\n      requestAnimationFrame(function () {\n        _this.clearMouseCanvas();\n\n        _this.draw({\n          trigger: \"drag\"\n        });\n      });\n    };\n\n    _this.handleDragEnd = function (_ref5, e) {\n      var mouseXY = _ref5.mouseXY;\n\n      _this.triggerEvent(\"dragend\", {\n        mouseXY: mouseXY\n      }, e);\n\n      requestAnimationFrame(function () {\n        _this.clearMouseCanvas();\n\n        _this.draw({\n          trigger: \"dragend\"\n        });\n      });\n    };\n\n    _this.handleClick = function (_, e) {\n      _this.triggerEvent(\"click\", _this.mutableState, e);\n\n      requestAnimationFrame(function () {\n        _this.clearMouseCanvas();\n\n        _this.draw({\n          trigger: \"click\"\n        });\n      });\n    };\n\n    _this.handleDoubleClick = function (_, e) {\n      _this.triggerEvent(\"dblclick\", {}, e);\n    };\n\n    _this.resetYDomain = function (chartId) {\n      var chartConfig = _this.state.chartConfig;\n      var changed = false;\n      var newChartConfig = chartConfig.map(function (each) {\n        if ((isNotDefined(chartId) || each.id === chartId) && !shallowEqual(each.yScale.domain(), each.realYDomain)) {\n          changed = true;\n          return Object.assign(Object.assign({}, each), {\n            yScale: each.yScale.domain(each.realYDomain),\n            yPanEnabled: false\n          });\n        }\n\n        return each;\n      });\n\n      if (changed) {\n        _this.clearThreeCanvas();\n\n        _this.setState({\n          chartConfig: newChartConfig\n        });\n      }\n    };\n\n    var _a = resetChart(props),\n        fullData = _a.fullData,\n        state = __rest(_a, [\"fullData\"]);\n\n    _this.state = state;\n    _this.fullData = fullData;\n    return _this;\n  }\n\n  _createClass(ChartCanvas, [{\n    key: \"clearBothCanvas\",\n    value: function clearBothCanvas() {\n      var canvases = this.getCanvasContexts();\n\n      if (canvases && canvases.axes && canvases.mouseCoord) {\n        clearCanvas([canvases.axes, canvases.mouseCoord], this.props.ratio);\n      }\n    }\n  }, {\n    key: \"clearMouseCanvas\",\n    value: function clearMouseCanvas() {\n      var canvases = this.getCanvasContexts();\n\n      if (canvases && canvases.mouseCoord) {\n        clearCanvas([canvases.mouseCoord], this.props.ratio);\n      }\n    }\n  }, {\n    key: \"clearThreeCanvas\",\n    value: function clearThreeCanvas() {\n      var canvases = this.getCanvasContexts();\n\n      if (canvases && canvases.axes && canvases.mouseCoord && canvases.bg) {\n        clearCanvas([canvases.axes, canvases.mouseCoord, canvases.bg], this.props.ratio);\n      }\n    }\n  }, {\n    key: \"cancelDrag\",\n    value: function cancelDrag() {\n      var _a;\n\n      (_a = this.eventCaptureRef.current) === null || _a === void 0 ? void 0 : _a.cancelDrag();\n      this.triggerEvent(\"dragcancel\");\n    }\n  }, {\n    key: \"triggerEvent\",\n    value: function triggerEvent(type, props, e) {\n      var _this2 = this;\n\n      this.subscriptions.forEach(function (each) {\n        var state = Object.assign(Object.assign({}, _this2.state), {\n          fullData: _this2.fullData,\n          subscriptions: _this2.subscriptions\n        });\n        each.listener(type, props, state, e);\n      });\n    }\n  }, {\n    key: \"getChildContext\",\n    value: function getChildContext() {\n      var dimensions = getDimensions(this.props);\n      return {\n        fullData: this.fullData,\n        plotData: this.state.plotData,\n        width: dimensions.width,\n        height: dimensions.height,\n        chartConfig: this.state.chartConfig,\n        xScale: this.state.xScale,\n        xAccessor: this.state.xAccessor,\n        displayXAccessor: this.state.displayXAccessor,\n        margin: this.props.margin,\n        ratio: this.props.ratio,\n        xAxisZoom: this.xAxisZoom,\n        yAxisZoom: this.yAxisZoom,\n        getCanvasContexts: this.getCanvasContexts,\n        redraw: this.redraw,\n        subscribe: this.subscribe,\n        unsubscribe: this.unsubscribe,\n        generateSubscriptionId: this.generateSubscriptionId,\n        getMutableState: this.getMutableState,\n        amIOnTop: this.amIOnTop,\n        setCursorClass: this.setCursorClass\n      };\n    }\n  }, {\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      var reset = shouldResetChart(this.props, nextProps);\n      var _this$state8 = this.state,\n          initialChartConfig = _this$state8.chartConfig,\n          plotData = _this$state8.plotData,\n          xAccessor = _this$state8.xAccessor,\n          xScale = _this$state8.xScale;\n      var interaction = isInteractionEnabled(xScale, xAccessor, plotData);\n      var newState;\n\n      if (!interaction || reset || !shallowEqual(this.props.xExtents, nextProps.xExtents)) {\n        // do reset\n        newState = resetChart(nextProps);\n        this.mutableState = {};\n      } else {\n        var _xScale$domain = xScale.domain(),\n            _xScale$domain2 = _slicedToArray(_xScale$domain, 2),\n            start = _xScale$domain2[0],\n            end = _xScale$domain2[1];\n\n        var prevLastItem = last(this.fullData);\n        var calculatedState = calculateFullData(nextProps);\n        var _xAccessor = calculatedState.xAccessor;\n\n        var previousX = _xAccessor(prevLastItem);\n\n        var lastItemWasVisible = previousX <= end && previousX >= start;\n        newState = updateChart(calculatedState, xScale, nextProps, lastItemWasVisible, initialChartConfig);\n      }\n\n      var _newState = newState,\n          fullData = _newState.fullData,\n          state = __rest(newState, [\"fullData\"]);\n\n      if (!this.panInProgress) {\n        this.clearThreeCanvas();\n        this.setState(state);\n      }\n\n      this.fullData = fullData;\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate() {\n      return !this.panInProgress;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props6 = this.props,\n          disableInteraction = _this$props6.disableInteraction,\n          disablePan = _this$props6.disablePan,\n          disableZoom = _this$props6.disableZoom,\n          useCrossHairStyleCursor = _this$props6.useCrossHairStyleCursor,\n          onClick = _this$props6.onClick,\n          onDoubleClick = _this$props6.onDoubleClick,\n          height = _this$props6.height,\n          width = _this$props6.width,\n          _this$props6$margin = _this$props6.margin,\n          margin = _this$props6$margin === void 0 ? ChartCanvas.defaultProps.margin : _this$props6$margin,\n          className = _this$props6.className,\n          _this$props6$zIndex = _this$props6.zIndex,\n          zIndex = _this$props6$zIndex === void 0 ? ChartCanvas.defaultProps.zIndex : _this$props6$zIndex,\n          defaultFocus = _this$props6.defaultFocus,\n          ratio = _this$props6.ratio,\n          mouseMoveEvent = _this$props6.mouseMoveEvent;\n      var _this$state9 = this.state,\n          plotData = _this$state9.plotData,\n          xScale = _this$state9.xScale,\n          xAccessor = _this$state9.xAccessor,\n          chartConfig = _this$state9.chartConfig;\n      var dimensions = getDimensions(this.props);\n      var interaction = isInteractionEnabled(xScale, xAccessor, plotData);\n      var cursorStyle = useCrossHairStyleCursor && interaction;\n      var cursor = getCursorStyle();\n      return React.createElement(\"div\", {\n        style: {\n          position: \"relative\",\n          width: width,\n          height: height\n        },\n        className: className,\n        onClick: onClick,\n        onDoubleClick: onDoubleClick\n      }, React.createElement(CanvasContainer, {\n        ref: this.canvasContainerRef,\n        ratio: ratio,\n        width: width,\n        height: height,\n        style: {\n          height: height,\n          zIndex: zIndex,\n          width: width\n        }\n      }), React.createElement(\"svg\", {\n        className: className,\n        width: width,\n        height: height,\n        style: {\n          position: \"absolute\",\n          zIndex: zIndex + 5\n        }\n      }, cursor, React.createElement(\"defs\", null, React.createElement(\"clipPath\", {\n        id: \"chart-area-clip\"\n      }, React.createElement(\"rect\", {\n        x: \"0\",\n        y: \"0\",\n        width: dimensions.width,\n        height: dimensions.height\n      })), chartConfig.map(function (each, idx) {\n        return React.createElement(\"clipPath\", {\n          key: idx,\n          id: \"chart-area-clip-\".concat(each.id)\n        }, React.createElement(\"rect\", {\n          x: \"0\",\n          y: \"0\",\n          width: each.width,\n          height: each.height\n        }));\n      })), React.createElement(\"g\", {\n        transform: \"translate(\".concat(margin.left + 0.5, \", \").concat(margin.top + 0.5, \")\")\n      }, React.createElement(EventCapture, {\n        ref: this.eventCaptureRef,\n        useCrossHairStyleCursor: cursorStyle,\n        mouseMove: mouseMoveEvent && interaction,\n        zoom: !disableZoom && interaction,\n        pan: !disablePan && interaction,\n        width: dimensions.width,\n        height: dimensions.height,\n        chartConfig: chartConfig,\n        xScale: xScale,\n        xAccessor: xAccessor,\n        focus: defaultFocus,\n        disableInteraction: disableInteraction,\n        getAllPanConditions: this.getAllPanConditions,\n        onContextMenu: this.handleContextMenu,\n        onClick: this.handleClick,\n        onDoubleClick: this.handleDoubleClick,\n        onMouseDown: this.handleMouseDown,\n        onMouseMove: this.handleMouseMove,\n        onMouseEnter: this.handleMouseEnter,\n        onMouseLeave: this.handleMouseLeave,\n        onDragStart: this.handleDragStart,\n        onDrag: this.handleDrag,\n        onDragComplete: this.handleDragEnd,\n        onZoom: this.handleZoom,\n        onPinchZoom: this.handlePinchZoom,\n        onPinchZoomEnd: this.handlePinchZoomEnd,\n        onPan: this.handlePan,\n        onPanEnd: this.handlePanEnd\n      }), React.createElement(\"g\", {\n        className: \"react-financial-charts-avoid-interaction\"\n      }, this.props.children))));\n    }\n  }]);\n\n  return ChartCanvas;\n}(React.Component);\nChartCanvas.defaultProps = {\n  clamp: false,\n  className: \"react-financial-charts\",\n  defaultFocus: true,\n  disablePan: false,\n  disableInteraction: false,\n  disableZoom: false,\n  flipXScale: false,\n  maintainPointsPerPixelOnResize: true,\n  margin: {\n    top: 0,\n    right: 40,\n    bottom: 40,\n    left: 0\n  },\n  minPointsPerPxThreshold: 1 / 100,\n  mouseMoveEvent: true,\n  postCalculator: identity,\n  padding: 0,\n  pointsPerPxThreshold: 2,\n  useCrossHairStyleCursor: true,\n  xAccessor: identity,\n  xExtents: [min, max],\n  zIndex: 1,\n  zoomAnchor: mouseBasedZoomAnchor,\n  zoomMultiplier: 1.1\n};\nChartCanvas.childContextTypes = {\n  plotData: PropTypes.array,\n  fullData: PropTypes.array,\n  chartConfig: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n    origin: PropTypes.arrayOf(PropTypes.number).isRequired,\n    padding: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n      top: PropTypes.number,\n      bottom: PropTypes.number\n    })]),\n    yExtents: PropTypes.arrayOf(PropTypes.func),\n    yExtentsProvider: PropTypes.func,\n    yScale: PropTypes.func.isRequired,\n    mouseCoordinates: PropTypes.shape({\n      at: PropTypes.string,\n      format: PropTypes.func\n    }),\n    width: PropTypes.number.isRequired,\n    height: PropTypes.number.isRequired\n  })).isRequired,\n  xScale: PropTypes.func.isRequired,\n  xAccessor: PropTypes.func.isRequired,\n  displayXAccessor: PropTypes.func.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  margin: PropTypes.object.isRequired,\n  ratio: PropTypes.number.isRequired,\n  getCanvasContexts: PropTypes.func,\n  xAxisZoom: PropTypes.func,\n  yAxisZoom: PropTypes.func,\n  amIOnTop: PropTypes.func,\n  redraw: PropTypes.func,\n  subscribe: PropTypes.func,\n  unsubscribe: PropTypes.func,\n  setCursorClass: PropTypes.func,\n  generateSubscriptionId: PropTypes.func,\n  getMutableState: PropTypes.func\n};","map":null,"metadata":{},"sourceType":"module"}