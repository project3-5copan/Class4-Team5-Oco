{"ast":null,"code":"import _slicedToArray from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { max, min } from \"d3-array\";\nimport { getClosestItemIndexes, head, isDefined, isNotDefined, last } from \"../utils\";\n\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n  var lastItem = fallbackEnd.lastItem,\n      lastItemX = fallbackEnd.lastItemX;\n  var lastItemXValue = xAccessor(lastItem);\n\n  var _initialXScale$range = initialXScale.range(),\n      _initialXScale$range2 = _slicedToArray(_initialXScale$range, 2),\n      rangeStart = _initialXScale$range2[0],\n      rangeEnd = _initialXScale$range2[1];\n\n  var newEnd = (rangeEnd - rangeStart) / (lastItemX.valueOf() - rangeStart) * (lastItemXValue.valueOf() - start.valueOf()) + start.valueOf();\n  return newEnd;\n}\n\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n  function filterData(data, inputDomain, xAccessor, initialXScale) {\n    var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n        currentPlotData = _ref.currentPlotData,\n        currentDomain = _ref.currentDomain,\n        fallbackStart = _ref.fallbackStart,\n        fallbackEnd = _ref.fallbackEnd,\n        _ref$ignoreThresholds = _ref.ignoreThresholds,\n        ignoreThresholds = _ref$ignoreThresholds === void 0 ? false : _ref$ignoreThresholds;\n\n    if (useWholeData) {\n      return {\n        plotData: data,\n        domain: inputDomain\n      };\n    }\n\n    var left = head(inputDomain);\n    var right = last(inputDomain);\n    var clampedDomain = inputDomain;\n    var filteredData = getFilteredResponse(data, left, right, xAccessor);\n\n    if (filteredData.length === 1 && fallbackStart !== undefined) {\n      left = fallbackStart;\n      right = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n      clampedDomain = [left, right];\n      filteredData = getFilteredResponse(data, left, right, xAccessor);\n    }\n\n    if (typeof clamp === \"function\") {\n      clampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n    } else {\n      if (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [max([left, xAccessor(head(data))]), clampedDomain[1]];\n      }\n\n      if (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [clampedDomain[0], min([right, xAccessor(last(data))])];\n      }\n    }\n\n    if (clampedDomain !== inputDomain) {\n      filteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n    }\n\n    var realInputDomain = clampedDomain;\n    var xScale = initialXScale.copy().domain(realInputDomain);\n    var width = Math.floor(xScale(xAccessor(last(filteredData))) - xScale(xAccessor(head(filteredData)))); // prevent negative width when flipXScale\n\n    if (flipXScale && width < 0) {\n      width = width * -1;\n    }\n\n    var plotData;\n    var domain;\n    var chartWidth = last(xScale.range()) - head(xScale.range());\n\n    if (ignoreThresholds && filteredData.length > 1 || canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n      plotData = filteredData;\n      domain = realInputDomain;\n    } else {\n      if (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n        plotData = filteredData;\n        var newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n        domain = [head(realInputDomain), newEnd];\n      } else {\n        plotData = currentPlotData !== null && currentPlotData !== void 0 ? currentPlotData : filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        domain = currentDomain !== null && currentDomain !== void 0 ? currentDomain : [xAccessor(head(plotData)), xAccessor(last(plotData))];\n      }\n    }\n\n    return {\n      plotData: plotData,\n      domain: domain\n    };\n  }\n\n  return {\n    filterData: filterData\n  };\n}\n\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n  var widthAdjustedMinThreshold = showMinThreshold(width, minThreshold);\n  var widthAdjustedMaxTheshold = showMaxThreshold(width, maxThreshold);\n  return arrayLength >= widthAdjustedMinThreshold && arrayLength < widthAdjustedMaxTheshold;\n}\n\nfunction showMinThreshold(width, threshold) {\n  return Math.max(1, Math.ceil(width * threshold));\n}\n\nfunction showMaxThreshold(width, threshold) {\n  return Math.floor(width * threshold);\n}\n\nfunction showMax(width, threshold) {\n  return Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\n\nfunction getFilteredResponse(data, left, right, xAccessor) {\n  var newLeftIndex = getClosestItemIndexes(data, left, xAccessor).left;\n  var newRightIndex = getClosestItemIndexes(data, right, xAccessor).right;\n  var filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n  return filteredData;\n}\n\nexport default function (_ref2) {\n  var xScale = _ref2.xScale,\n      useWholeData = _ref2.useWholeData,\n      clamp = _ref2.clamp,\n      pointsPerPxThreshold = _ref2.pointsPerPxThreshold,\n      minPointsPerPxThreshold = _ref2.minPointsPerPxThreshold,\n      flipXScale = _ref2.flipXScale;\n  return extentsWrapper(useWholeData || isNotDefined(xScale.invert), clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale);\n}","map":null,"metadata":{},"sourceType":"module"}