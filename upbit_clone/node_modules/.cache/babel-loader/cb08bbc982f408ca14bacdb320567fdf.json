{"ast":null,"code":"import _classCallCheck from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { group, merge } from \"d3-array\";\nimport { stack as d3Stack } from \"d3-shape\";\nimport * as React from \"react\";\nimport { functor, head, identity, getAxisCanvas, GenericChartComponent, plotDataLengthBarWidth } from \"@react-financial-charts/core\";\nexport var StackedBarSeries = /*#__PURE__*/function (_React$Component) {\n  _inherits(StackedBarSeries, _React$Component);\n\n  var _super = _createSuper(StackedBarSeries);\n\n  function StackedBarSeries() {\n    var _this;\n\n    _classCallCheck(this, StackedBarSeries);\n\n    _this = _super.apply(this, arguments);\n\n    _this.drawOnCanvas = function (ctx, moreProps) {\n      var xAccessor = moreProps.xAccessor;\n      drawOnCanvasHelper(ctx, _this.props, moreProps, xAccessor, d3Stack);\n    };\n\n    return _this;\n  }\n\n  _createClass(StackedBarSeries, [{\n    key: \"render\",\n    value: function render() {\n      var clip = this.props.clip;\n      return React.createElement(GenericChartComponent, {\n        clip: clip,\n        canvasDraw: this.drawOnCanvas,\n        canvasToDraw: getAxisCanvas,\n        drawOn: [\"pan\"]\n      });\n    }\n  }]);\n\n  return StackedBarSeries;\n}(React.Component);\nStackedBarSeries.defaultProps = {\n  baseAt: function baseAt(xScale, yScale) {\n    return head(yScale.range());\n  },\n  direction: \"up\",\n  stroke: false,\n  fillStyle: \"rgba(70, 130, 180, 0.5)\",\n  width: plotDataLengthBarWidth,\n  widthRatio: 0.8,\n  clip: true,\n  swapScales: false\n};\nexport function identityStack() {\n  var keys = [];\n\n  function stack(data) {\n    var response = keys.map(function (key, i) {\n      var arrays = data.map(function (d) {\n        var array = [0, d[key]]; // @ts-ignore\n\n        array.data = d;\n        return array;\n      });\n      arrays.key = key;\n      arrays.index = i;\n      return arrays;\n    });\n    return response;\n  }\n\n  stack.keys = function (x) {\n    if (!arguments.length) {\n      return keys;\n    }\n\n    keys = x;\n    return stack;\n  };\n\n  return stack;\n}\nexport function drawOnCanvasHelper(ctx, props, moreProps, xAccessor, stackFn) {\n  var defaultPostAction = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity;\n  var postRotateAction = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : rotateXY;\n  var xScale = moreProps.xScale,\n      yScale = moreProps.chartConfig.yScale,\n      plotData = moreProps.plotData;\n  var bars = doStuff(props, xAccessor, plotData, xScale, yScale, stackFn, postRotateAction, defaultPostAction);\n  drawOnCanvas2(props, ctx, bars);\n}\n\nfunction convertToArray(item) {\n  return Array.isArray(item) ? item : [item];\n}\n\nvar doStuff = function doStuff(props, xAccessor, plotData, xScale, yScale, stackFn, postRotateAction, defaultPostAction) {\n  var yAccessor = props.yAccessor,\n      swapScales = props.swapScales;\n  var modifiedYAccessor = swapScales ? convertToArray(xAccessor) : convertToArray(yAccessor);\n  var modifiedXAccessor = swapScales ? yAccessor : xAccessor;\n  var modifiedXScale = swapScales ? yScale : xScale;\n  var modifiedYScale = swapScales ? xScale : yScale;\n  var postProcessor = swapScales ? postRotateAction : defaultPostAction;\n  var bars = getBars(props, modifiedXAccessor, modifiedYAccessor, modifiedXScale, modifiedYScale, plotData, stackFn, postProcessor);\n  return bars;\n};\n\nexport var rotateXY = function rotateXY(array) {\n  return array.map(function (each) {\n    return Object.assign(Object.assign({}, each), {\n      x: each.y,\n      y: each.x,\n      height: each.width,\n      width: each.height\n    });\n  });\n};\nexport var drawOnCanvas2 = function drawOnCanvas2(props, ctx, bars) {\n  var stroke = props.stroke;\n  var nest = group(bars, function (d) {\n    return d.fillStyle;\n  });\n  nest.forEach(function (values, key) {\n    if (head(values).width > 1) {\n      if (key !== undefined) {\n        ctx.strokeStyle = key;\n      }\n    }\n\n    ctx.fillStyle = key;\n    values.forEach(function (d) {\n      if (d.width <= 1) {\n        ctx.fillRect(d.x - 0.5, d.y, 1, d.height);\n      } else {\n        ctx.fillRect(d.x + 0.5, d.y + 0.5, d.width, d.height);\n\n        if (stroke) {\n          ctx.strokeRect(d.x, d.y, d.width, d.height);\n        }\n      }\n    });\n  });\n};\nexport function getBars(props, xAccessor, yAccessor, xScale, yScale, plotData) {\n  var stack = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : identityStack;\n  var after = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : identity;\n  var baseAt = props.baseAt,\n      fillStyle = props.fillStyle,\n      stroke = props.stroke,\n      _props$spaceBetweenBa = props.spaceBetweenBar,\n      spaceBetweenBar = _props$spaceBetweenBa === void 0 ? 0 : _props$spaceBetweenBa;\n  var getFill = functor(fillStyle);\n  var getBase = functor(baseAt);\n  var widthFunctor = functor(props.width);\n  var width = widthFunctor(props, {\n    xScale: xScale,\n    xAccessor: xAccessor,\n    plotData: plotData\n  });\n  var barWidth = Math.round(width);\n  var eachBarWidth = (barWidth - spaceBetweenBar * (yAccessor.length - 1)) / yAccessor.length;\n  var offset = barWidth === 1 ? 0 : 0.5 * width;\n  var ds = plotData.map(function (each) {\n    var d = {\n      appearance: {},\n      x: xAccessor(each)\n    };\n    yAccessor.forEach(function (eachYAccessor, i) {\n      var key = \"y\".concat(i); // @ts-ignore\n\n      d[key] = eachYAccessor(each);\n      var appearance = {\n        stroke: stroke ? getFill(each, i) : \"none\",\n        fillStyle: getFill(each, i)\n      }; // @ts-ignore\n\n      d.appearance[key] = appearance;\n    });\n    return d;\n  });\n  var keys = yAccessor.map(function (_, i) {\n    return \"y\".concat(i);\n  }); // @ts-ignore\n\n  var data = stack().keys(keys)(ds);\n  var newData = data.map(function (each, i) {\n    var key = each.key;\n    return each.map(function (d) {\n      var array = [d[0], d[1]]; // @ts-ignore\n\n      array.data = {\n        x: d.data.x,\n        i: i,\n        appearance: d.data.appearance[key]\n      };\n      return array;\n    });\n  });\n  var bars = merge(newData).map(function (d) {\n    var y = yScale(d[1]);\n    var h = getBase(xScale, yScale, d.data) - yScale(d[1] - d[0]);\n\n    if (h < 0) {\n      y = y + h;\n      h = -h;\n    }\n\n    return Object.assign(Object.assign({}, d.data.appearance), {\n      x: Math.round(xScale(d.data.x) - width / 2),\n      y: y,\n      groupOffset: Math.round(offset - (d.data.i > 0 ? (eachBarWidth + spaceBetweenBar) * d.data.i : 0)),\n      groupWidth: Math.round(eachBarWidth),\n      offset: Math.round(offset),\n      height: h,\n      width: barWidth\n    });\n  }).filter(function (bar) {\n    return !isNaN(bar.y);\n  });\n  return after(bars);\n}","map":null,"metadata":{},"sourceType":"module"}