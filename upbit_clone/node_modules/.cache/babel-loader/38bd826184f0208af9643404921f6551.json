{"ast":null,"code":"import * as React from \"react\";\nimport { getStrokeDasharray, getStrokeDasharrayCanvas, isDefined } from \"@react-financial-charts/core\";\nexport var renderSVG = function renderSVG(props) {\n  var className = props.className;\n  var edge = helper(props);\n\n  if (edge === null) {\n    return null;\n  }\n\n  var line;\n  var coordinateBase;\n  var coordinate;\n\n  if (edge.line !== undefined) {\n    line = React.createElement(\"line\", {\n      className: \"react-financial-charts-cross-hair\",\n      stroke: edge.line.stroke,\n      strokeDasharray: getStrokeDasharray(edge.line.strokeDasharray),\n      x1: edge.line.x1,\n      y1: edge.line.y1,\n      x2: edge.line.x2,\n      y2: edge.line.y2\n    });\n  }\n\n  if (edge.coordinate !== undefined && edge.coordinateBase !== undefined) {\n    var _edge$coordinateBase = edge.coordinateBase,\n        rectWidth = _edge$coordinateBase.rectWidth,\n        rectHeight = _edge$coordinateBase.rectHeight,\n        arrowWidth = _edge$coordinateBase.arrowWidth;\n    var path = edge.orient === \"left\" ? \"M0,0L0,\".concat(rectHeight, \"L\").concat(rectWidth, \",\").concat(rectHeight, \"L\").concat(rectWidth + arrowWidth, \",10L\").concat(rectWidth, \",0L0,0L0,0\") : \"M0,\".concat(arrowWidth, \"L\").concat(arrowWidth, \",\").concat(rectHeight, \"L\").concat(rectWidth + arrowWidth, \",\").concat(rectHeight, \"L\").concat(rectWidth + arrowWidth, \",0L\").concat(arrowWidth, \",0L0,\").concat(arrowWidth);\n    coordinateBase = edge.orient === \"left\" || edge.orient === \"right\" ? React.createElement(\"g\", {\n      key: 1,\n      transform: \"translate(\".concat(edge.coordinateBase.edgeXRect, \",\").concat(edge.coordinateBase.edgeYRect, \")\")\n    }, React.createElement(\"path\", {\n      d: path,\n      className: \"react-financial-charts-text-background\",\n      height: rectHeight,\n      width: rectWidth,\n      stroke: edge.coordinateBase.stroke,\n      strokeLinejoin: \"miter\",\n      strokeWidth: edge.coordinateBase.strokeWidth,\n      fill: edge.coordinateBase.fill\n    })) : React.createElement(\"rect\", {\n      key: 1,\n      className: \"react-financial-charts-text-background\",\n      x: edge.coordinateBase.edgeXRect,\n      y: edge.coordinateBase.edgeYRect,\n      height: rectHeight,\n      width: rectWidth,\n      fill: edge.coordinateBase.fill\n    });\n    coordinate = React.createElement(\"text\", {\n      key: 2,\n      x: edge.coordinate.edgeXText,\n      y: edge.coordinate.edgeYText,\n      textAnchor: edge.coordinate.textAnchor,\n      fontFamily: edge.coordinate.fontFamily,\n      fontSize: edge.coordinate.fontSize,\n      dy: \".32em\",\n      fill: edge.coordinate.textFill\n    }, edge.coordinate.displayCoordinate);\n  }\n\n  return React.createElement(\"g\", {\n    className: className\n  }, line, coordinateBase, coordinate);\n};\n\nvar helper = function helper(props) {\n  var displayCoordinate = props.coordinate,\n      show = props.show,\n      type = props.type,\n      orient = props.orient,\n      edgeAt = props.edgeAt,\n      hideLine = props.hideLine,\n      lineStrokeDasharray = props.lineStrokeDasharray,\n      fill = props.fill,\n      fontFamily = props.fontFamily,\n      fontSize = props.fontSize,\n      textFill = props.textFill,\n      lineStroke = props.lineStroke,\n      stroke = props.stroke,\n      strokeWidth = props.strokeWidth,\n      arrowWidth = props.arrowWidth,\n      rectWidth = props.rectWidth,\n      rectHeight = props.rectHeight,\n      rectRadius = props.rectRadius,\n      x1 = props.x1,\n      y1 = props.y1,\n      x2 = props.x2,\n      y2 = props.y2,\n      dx = props.dx;\n\n  if (!show) {\n    return null;\n  }\n\n  var coordinateBase;\n  var coordinate;\n\n  if (displayCoordinate !== undefined) {\n    var textAnchor = \"middle\";\n    var edgeXRect;\n    var edgeYRect;\n    var edgeXText;\n    var edgeYText;\n\n    if (type === \"horizontal\") {\n      edgeXRect = dx + (orient === \"right\" ? edgeAt + 1 : edgeAt - rectWidth - 1);\n      edgeYRect = y1 - rectHeight / 2 - strokeWidth;\n      edgeXText = dx + (orient === \"right\" ? edgeAt + rectWidth / 2 : edgeAt - rectWidth / 2);\n      edgeYText = y1;\n    } else {\n      var dy = orient === \"bottom\" ? strokeWidth - 1 : -strokeWidth + 1;\n      edgeXRect = x1 - rectWidth / 2;\n      edgeYRect = (orient === \"bottom\" ? edgeAt : edgeAt - rectHeight) + dy;\n      edgeXText = x1;\n      edgeYText = (orient === \"bottom\" ? edgeAt + rectHeight / 2 : edgeAt - rectHeight / 2) + dy;\n    }\n\n    coordinateBase = {\n      edgeXRect: edgeXRect,\n      edgeYRect: edgeYRect,\n      rectHeight: rectHeight + strokeWidth,\n      rectWidth: rectWidth,\n      rectRadius: rectRadius,\n      fill: fill,\n      arrowWidth: arrowWidth,\n      stroke: stroke,\n      strokeWidth: strokeWidth\n    };\n    coordinate = {\n      edgeXText: edgeXText,\n      edgeYText: edgeYText,\n      textAnchor: textAnchor,\n      fontFamily: fontFamily,\n      fontSize: fontSize,\n      textFill: textFill,\n      displayCoordinate: displayCoordinate\n    };\n  }\n\n  var line = hideLine ? undefined : {\n    stroke: lineStroke,\n    strokeDasharray: lineStrokeDasharray,\n    x1: x1,\n    y1: y1,\n    x2: x2,\n    y2: y2\n  };\n  return {\n    coordinateBase: coordinateBase,\n    coordinate: coordinate,\n    line: line,\n    orient: orient\n  };\n};\n\nexport var drawOnCanvas = function drawOnCanvas(ctx, props) {\n  var coordinate = props.coordinate,\n      fitToText = props.fitToText,\n      fontSize = props.fontSize,\n      fontFamily = props.fontFamily,\n      rectWidth = props.rectWidth;\n  ctx.font = \"\".concat(fontSize, \"px \").concat(fontFamily);\n  ctx.textBaseline = \"middle\";\n  var width = rectWidth;\n\n  if (fitToText) {\n    width = Math.round(ctx.measureText(coordinate).width + 10);\n  }\n\n  var edge = helper(Object.assign(Object.assign({}, props), {\n    rectWidth: width\n  }));\n\n  if (edge === null) {\n    return;\n  }\n\n  if (edge.line !== undefined && isDefined(edge.line)) {\n    var dashArray = getStrokeDasharrayCanvas(edge.line.strokeDasharray);\n    ctx.setLineDash(dashArray);\n    ctx.strokeStyle = edge.line.stroke;\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(edge.line.x1, edge.line.y1);\n    ctx.lineTo(edge.line.x2, edge.line.y2);\n    ctx.stroke();\n  }\n\n  ctx.setLineDash([]);\n\n  if (edge.coordinateBase !== undefined) {\n    var _edge$coordinateBase2 = edge.coordinateBase,\n        arrowWidth = _edge$coordinateBase2.arrowWidth,\n        _rectWidth = _edge$coordinateBase2.rectWidth,\n        rectHeight = _edge$coordinateBase2.rectHeight,\n        rectRadius = _edge$coordinateBase2.rectRadius;\n    ctx.fillStyle = edge.coordinateBase.fill;\n\n    if (edge.coordinateBase.stroke !== undefined) {\n      ctx.strokeStyle = edge.coordinateBase.stroke;\n      ctx.lineWidth = edge.coordinateBase.strokeWidth;\n    }\n\n    var x = edge.coordinateBase.edgeXRect;\n    var y = edge.coordinateBase.edgeYRect;\n    var halfHeight = rectHeight / 2;\n    ctx.beginPath();\n\n    if (arrowWidth > 0 && edge.orient === \"right\") {\n      x -= arrowWidth;\n      ctx.moveTo(x, y + halfHeight);\n      ctx.lineTo(x + arrowWidth, y);\n      ctx.lineTo(x + _rectWidth + arrowWidth, y);\n      ctx.lineTo(x + _rectWidth + arrowWidth, y + rectHeight);\n      ctx.lineTo(x + arrowWidth, y + rectHeight);\n      ctx.closePath();\n    } else if (arrowWidth > 0 && edge.orient === \"left\") {\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + _rectWidth, y);\n      ctx.lineTo(x + _rectWidth + arrowWidth, y + halfHeight);\n      ctx.lineTo(x + _rectWidth, y + rectHeight);\n      ctx.lineTo(x, y + rectHeight);\n      ctx.closePath();\n    } else if (rectRadius) {\n      roundRect(ctx, x - 0.5, y - 0.5, _rectWidth, rectHeight, 3);\n    } else {\n      ctx.rect(x - 0.5, y, _rectWidth, rectHeight);\n    }\n\n    ctx.fill();\n\n    if (edge.coordinateBase.stroke !== undefined) {\n      ctx.stroke();\n    }\n\n    if (edge.coordinate !== undefined) {\n      ctx.fillStyle = edge.coordinate.textFill;\n      ctx.textAlign = edge.coordinate.textAnchor === \"middle\" ? \"center\" : edge.coordinate.textAnchor;\n      ctx.fillText(edge.coordinate.displayCoordinate, edge.coordinate.edgeXText, edge.coordinate.edgeYText);\n    }\n  }\n};\n\nvar roundRect = function roundRect(ctx, x, y, width, height, radius) {\n  ctx.beginPath();\n  ctx.moveTo(x + radius, y);\n  ctx.lineTo(x + width - radius, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n  ctx.lineTo(x + width, y + height - radius);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n  ctx.lineTo(x + radius, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n  ctx.lineTo(x, y + radius);\n  ctx.quadraticCurveTo(x, y, x + radius, y);\n  ctx.closePath();\n};","map":null,"metadata":{},"sourceType":"module"}