{"ast":null,"code":"import { PointAndFigure as defaultOptions } from \"./defaultOptionsForComputation\";\n\nfunction createBox(d, dateAccessor, dateMutator) {\n  var box = {\n    open: d.open,\n    fromDate: dateAccessor(d),\n    toDate: dateAccessor(d),\n    startOfYear: d.startOfYear,\n    startOfQuarter: d.startOfQuarter,\n    startOfMonth: d.startOfMonth,\n    startOfWeek: d.startOfWeek\n  };\n  dateMutator(box, dateAccessor(d));\n  return box;\n}\n\nfunction updateColumns(columnData, dateAccessor, dateMutator) {\n  columnData.forEach(function (d) {\n    d.startOfYear = false;\n    d.startOfQuarter = false;\n    d.startOfMonth = false;\n    d.startOfWeek = false;\n    d.boxes.forEach(function (eachBox) {\n      if (d.open === undefined) {\n        d.open = eachBox.open;\n      }\n\n      d.close = eachBox.close;\n      d.high = Math.max(d.open, d.close);\n      d.low = Math.min(d.open, d.close);\n\n      if (d.fromDate === undefined) {\n        d.fromDate = eachBox.fromDate;\n      }\n\n      if (d.date === undefined) {\n        d.date = eachBox.date;\n      }\n\n      d.toDate = eachBox.toDate;\n\n      if (eachBox.startOfYear) {\n        d.startOfYear = d.startOfYear || eachBox.startOfYear;\n        d.startOfQuarter = eachBox.startOfQuarter;\n        d.startOfMonth = eachBox.startOfMonth;\n        d.startOfWeek = eachBox.startOfWeek;\n        dateMutator(d, dateAccessor(eachBox));\n      }\n\n      if (d.startOfQuarter !== true && eachBox.startOfQuarter) {\n        d.startOfQuarter = eachBox.startOfQuarter;\n        d.startOfMonth = eachBox.startOfMonth;\n        d.startOfWeek = eachBox.startOfWeek;\n        dateMutator(d, dateAccessor(eachBox));\n      }\n\n      if (d.startOfMonth !== true && eachBox.startOfMonth) {\n        d.startOfMonth = eachBox.startOfMonth;\n        d.startOfWeek = eachBox.startOfWeek;\n        dateMutator(d, dateAccessor(eachBox));\n      }\n\n      if (d.startOfWeek !== true && eachBox.startOfWeek) {\n        d.startOfWeek = eachBox.startOfWeek;\n        dateMutator(d, dateAccessor(eachBox));\n      }\n    });\n  });\n  return columnData;\n}\n\nexport default function () {\n  var options = defaultOptions;\n\n  var dateAccessor = function dateAccessor(d) {\n    return d.date;\n  };\n\n  var dateMutator = function dateMutator(d, date) {\n    d.date = date;\n  };\n\n  var calculator = function calculator(rawData) {\n    var _options = options,\n        reversal = _options.reversal,\n        boxSize = _options.boxSize,\n        sourcePath = _options.sourcePath;\n    var source = // eslint-disable-next-line prettier/prettier\n    sourcePath === \"high/low\" ? function (d) {\n      return {\n        high: d.high,\n        low: d.low\n      };\n    } : function (d) {\n      return {\n        high: d.close,\n        low: d.close\n      };\n    };\n    var pricingMethod = source;\n    var columnData = []; // @ts-ignore\n\n    var column = {\n      boxes: [],\n      open: rawData[0].open\n    };\n    var box = createBox(rawData[0], dateAccessor, dateMutator);\n    columnData.push(column);\n    rawData.forEach(function (d) {\n      // @ts-ignore\n      column.volume = (column.volume || 0) + d.volume;\n\n      if (!box.startOfYear) {\n        box.startOfYear = d.startOfYear;\n\n        if (box.startOfYear) {\n          dateMutator(box, dateAccessor(d));\n        }\n      }\n\n      if (!box.startOfYear && !box.startOfQuarter) {\n        box.startOfQuarter = d.startOfQuarter;\n\n        if (box.startOfQuarter && !box.startOfYear) {\n          dateMutator(box, dateAccessor(d));\n        }\n      }\n\n      if (!box.startOfQuarter && !box.startOfMonth) {\n        box.startOfMonth = d.startOfMonth;\n\n        if (box.startOfMonth && !box.startOfQuarter) {\n          dateMutator(box, dateAccessor(d));\n        }\n      }\n\n      if (!box.startOfMonth && !box.startOfWeek) {\n        box.startOfWeek = d.startOfWeek;\n\n        if (box.startOfWeek && !box.startOfMonth) {\n          dateMutator(box, dateAccessor(d));\n        }\n      }\n\n      if (columnData.length === 1 && column.boxes.length === 0) {\n        var upwardMovement = Math.max(pricingMethod(d).high - column.open, 0); // upward movement\n\n        var downwardMovement = Math.abs(Math.min(column.open - pricingMethod(d).low, 0)); // downward movement\n\n        column.direction = upwardMovement > downwardMovement ? 1 : -1;\n\n        if (boxSize * reversal < upwardMovement || boxSize * reversal < downwardMovement) {\n          // enough movement to trigger a reversal\n          box.toDate = dateAccessor(d);\n          box.open = column.open;\n          var noOfBoxes = column.direction > 0 ? Math.floor(upwardMovement / boxSize) : Math.floor(downwardMovement / boxSize);\n\n          for (var i = 0; i < noOfBoxes; i++) {\n            // @ts-ignore\n            box.close = box.open + column.direction * boxSize; // @ts-ignore\n\n            var prevBoxClose = box.close;\n            column.boxes.push(box);\n            box = createBox(box, dateAccessor, dateMutator); // box = cloneMe(box);\n\n            box.open = prevBoxClose;\n          }\n\n          box.fromDate = dateAccessor(d); // @ts-ignore\n\n          box.date = dateAccessor(d);\n        }\n      } else {\n        // one or more boxes already formed in the current column\n        var _upwardMovement = Math.max(pricingMethod(d).high - box.open, 0); // upward movement\n\n\n        var _downwardMovement = Math.abs(Math.min(pricingMethod(d).low - box.open, 0)); // downward movement\n\n\n        if (column.direction > 0 && _upwardMovement > boxSize ||\n        /* rising column AND box can be formed */\n        column.direction < 0 && _downwardMovement > boxSize\n        /* falling column AND box can be formed */\n        ) {\n            // form another box\n            // @ts-ignore\n            box.close = box.open + column.direction * boxSize;\n            box.toDate = dateAccessor(d); // @ts-ignore\n\n            var _prevBoxClose = box.close;\n            column.boxes.push(box);\n            box = createBox(d, dateAccessor, dateMutator);\n            box.open = _prevBoxClose;\n            box.fromDate = dateAccessor(d);\n            dateMutator(box, dateAccessor(d));\n          } else if (\n        /* rising column and there is downward movement to trigger a reversal */\n        column.direction > 0 && _downwardMovement > boxSize * reversal ||\n        /* falling column and there is downward movement to trigger a reversal */\n        column.direction < 0 && _upwardMovement > boxSize * reversal) {\n          // reversal\n          box.open = box.open + -1 * column.direction * boxSize;\n          box.toDate = dateAccessor(d); // box.displayDate = d.displayDate;\n\n          dateMutator(box, dateAccessor(d)); // box.startOfYear = d.startOfYear;\n          // box.startOfQuarter = d.startOfQuarter;\n          // box.startOfMonth = d.startOfMonth;\n          // box.startOfWeek = d.startOfWeek;\n          // var idx = index + 1;\n\n          column = {\n            boxes: [],\n            // @ts-ignore\n            volume: 0,\n            direction: -1 * column.direction\n          };\n\n          var _noOfBoxes = column.direction > 0 ? Math.floor(_upwardMovement / boxSize) : Math.floor(_downwardMovement / boxSize);\n\n          for (var _i = 0; _i < _noOfBoxes; _i++) {\n            // @ts-ignore\n            box.close = box.open + column.direction * boxSize; // @ts-ignore\n\n            var _prevBoxClose2 = box.close;\n            column.boxes.push(box);\n            box = createBox(d, dateAccessor, dateMutator);\n            box.open = _prevBoxClose2;\n          }\n\n          columnData.push(column);\n        }\n      }\n    });\n    updateColumns(columnData, dateAccessor, dateMutator);\n    return columnData;\n  };\n\n  calculator.options = function (newOptions) {\n    if (newOptions === undefined) {\n      return options;\n    }\n\n    options = Object.assign(Object.assign({}, defaultOptions), newOptions);\n    return calculator;\n  };\n\n  calculator.dateMutator = function (newDateMutator) {\n    if (newDateMutator === undefined) {\n      return dateMutator;\n    }\n\n    dateMutator = newDateMutator;\n    return calculator;\n  };\n\n  calculator.dateAccessor = function (newDateAccessor) {\n    if (newDateAccessor === undefined) {\n      return dateAccessor;\n    }\n\n    dateAccessor = newDateAccessor;\n    return calculator;\n  };\n\n  return calculator;\n}","map":null,"metadata":{},"sourceType":"module"}