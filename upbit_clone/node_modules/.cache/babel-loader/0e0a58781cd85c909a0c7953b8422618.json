{"ast":null,"code":"import _slicedToArray from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { first, getAxisCanvas, GenericChartComponent, getStrokeDasharrayCanvas, last } from \"@react-financial-charts/core\";\nimport { range as d3Range, zip } from \"d3-array\";\nimport { forceCollide, forceSimulation, forceX } from \"d3-force\";\nimport * as React from \"react\";\nimport { AxisZoomCapture } from \"./AxisZoomCapture\";\nexport var Axis = /*#__PURE__*/function (_React$Component) {\n  _inherits(Axis, _React$Component);\n\n  var _super = _createSuper(Axis);\n\n  function Axis() {\n    var _this;\n\n    _classCallCheck(this, Axis);\n\n    _this = _super.apply(this, arguments);\n    _this.chartRef = React.createRef();\n\n    _this.getMoreProps = function () {\n      return _this.chartRef.current.getMoreProps();\n    };\n\n    _this.drawOnCanvas = function (ctx, moreProps) {\n      var _this$props = _this.props,\n          showDomain = _this$props.showDomain,\n          showGridLines = _this$props.showGridLines,\n          showTickLabel = _this$props.showTickLabel,\n          showTicks = _this$props.showTicks,\n          transform = _this$props.transform,\n          range = _this$props.range,\n          getScale = _this$props.getScale,\n          tickLabelFill = _this$props.tickLabelFill;\n      ctx.save();\n      ctx.translate(transform[0], transform[1]);\n      var scale = getScale(moreProps);\n      var tickProps = tickHelper(_this.props, scale);\n\n      if (showTicks) {\n        drawTicks(ctx, tickProps);\n      }\n\n      if (showGridLines) {\n        tickProps.ticks.forEach(function (tick) {\n          drawGridLine(ctx, tick, tickProps, moreProps);\n        });\n      }\n\n      if (showTickLabel) {\n        var fontFamily = tickProps.fontFamily,\n            fontSize = tickProps.fontSize,\n            fontWeight = tickProps.fontWeight,\n            textAnchor = tickProps.textAnchor;\n        ctx.font = \"\".concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n\n        if (tickLabelFill !== undefined) {\n          ctx.fillStyle = tickLabelFill;\n        }\n\n        ctx.textAlign = textAnchor === \"middle\" ? \"center\" : textAnchor;\n        tickProps.ticks.forEach(function (tick) {\n          drawEachTickLabel(ctx, tick, tickProps);\n        });\n      }\n\n      if (showDomain) {\n        drawAxisLine(ctx, _this.props, range);\n      }\n\n      ctx.restore();\n    };\n\n    return _this;\n  }\n\n  _createClass(Axis, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          bg = _this$props2.bg,\n          axisZoomCallback = _this$props2.axisZoomCallback,\n          className = _this$props2.className,\n          zoomCursorClassName = _this$props2.zoomCursorClassName,\n          zoomEnabled = _this$props2.zoomEnabled,\n          getScale = _this$props2.getScale,\n          inverted = _this$props2.inverted,\n          transform = _this$props2.transform,\n          getMouseDelta = _this$props2.getMouseDelta,\n          edgeClip = _this$props2.edgeClip,\n          onContextMenu = _this$props2.onContextMenu,\n          onDoubleClick = _this$props2.onDoubleClick;\n      var zoomCapture = zoomEnabled ? React.createElement(AxisZoomCapture, {\n        bg: bg,\n        getScale: getScale,\n        getMoreProps: this.getMoreProps,\n        getMouseDelta: getMouseDelta,\n        axisZoomCallback: axisZoomCallback,\n        className: className,\n        zoomCursorClassName: zoomCursorClassName,\n        inverted: inverted,\n        onContextMenu: onContextMenu,\n        onDoubleClick: onDoubleClick\n      }) : null;\n      return React.createElement(\"g\", {\n        transform: \"translate(\".concat(transform[0], \", \").concat(transform[1], \")\")\n      }, zoomCapture, React.createElement(GenericChartComponent, {\n        ref: this.chartRef,\n        canvasToDraw: getAxisCanvas,\n        clip: false,\n        edgeClip: edgeClip,\n        canvasDraw: this.drawOnCanvas,\n        drawOn: [\"pan\"]\n      }));\n    }\n  }]);\n\n  return Axis;\n}(React.Component);\nAxis.defaultProps = {\n  edgeClip: false,\n  zoomEnabled: false,\n  zoomCursorClassName: \"\"\n};\n\nvar tickHelper = function tickHelper(props, scale) {\n  var orient = props.orient,\n      _props$innerTickSize = props.innerTickSize,\n      innerTickSize = _props$innerTickSize === void 0 ? 4 : _props$innerTickSize,\n      tickFormat = props.tickFormat,\n      _props$tickPadding = props.tickPadding,\n      tickPadding = _props$tickPadding === void 0 ? 4 : _props$tickPadding,\n      tickLabelFill = props.tickLabelFill,\n      tickStrokeWidth = props.tickStrokeWidth,\n      tickStrokeDasharray = props.tickStrokeDasharray,\n      _props$fontSize = props.fontSize,\n      fontSize = _props$fontSize === void 0 ? 12 : _props$fontSize,\n      fontFamily = props.fontFamily,\n      fontWeight = props.fontWeight,\n      showTicks = props.showTicks,\n      showTickLabel = props.showTickLabel,\n      tickArguments = props.ticks,\n      tickValuesProp = props.tickValues,\n      tickStrokeStyle = props.tickStrokeStyle,\n      tickInterval = props.tickInterval,\n      tickIntervalFunction = props.tickIntervalFunction,\n      rest = __rest(props, [\"orient\", \"innerTickSize\", \"tickFormat\", \"tickPadding\", \"tickLabelFill\", \"tickStrokeWidth\", \"tickStrokeDasharray\", \"fontSize\", \"fontFamily\", \"fontWeight\", \"showTicks\", \"showTickLabel\", \"ticks\", \"tickValues\", \"tickStrokeStyle\", \"tickInterval\", \"tickIntervalFunction\"]);\n\n  var tickValues;\n\n  if (tickValuesProp !== undefined) {\n    if (typeof tickValuesProp === \"function\") {\n      tickValues = tickValuesProp(scale.domain());\n    } else {\n      tickValues = tickValuesProp;\n    }\n  } else if (tickInterval !== undefined) {\n    var _scale$domain = scale.domain(),\n        _scale$domain2 = _slicedToArray(_scale$domain, 2),\n        min = _scale$domain2[0],\n        max = _scale$domain2[1];\n\n    var baseTickValues = d3Range(min, max, (max - min) / tickInterval);\n    tickValues = tickIntervalFunction ? tickIntervalFunction(min, max, tickInterval) : baseTickValues;\n  } else if (scale.ticks !== undefined) {\n    tickValues = scale.ticks(tickArguments);\n  } else {\n    tickValues = scale.domain();\n  }\n\n  var format = tickFormat === undefined ? scale.tickFormat(tickArguments) : function (d) {\n    return tickFormat(d) || \"\";\n  };\n  var sign = orient === \"top\" || orient === \"left\" ? -1 : 1;\n  var tickSpacing = Math.max(innerTickSize, 0) + tickPadding;\n  var ticks;\n  var dy; // tslint:disable-next-line: variable-name\n\n  var canvas_dy;\n  var textAnchor;\n\n  if (orient === \"bottom\" || orient === \"top\") {\n    dy = sign < 0 ? \"0em\" : \".71em\";\n    canvas_dy = sign < 0 ? 0 : fontSize * 0.71;\n    textAnchor = \"middle\";\n    var y2 = sign * innerTickSize;\n    var labelY = sign * tickSpacing;\n    ticks = tickValues.map(function (d) {\n      var x = Math.round(scale(d));\n      return {\n        value: d,\n        x1: x,\n        y1: 0,\n        x2: x,\n        y2: y2,\n        labelX: x,\n        labelY: labelY\n      };\n    });\n\n    if (showTicks) {\n      var nodes = ticks.map(function (d) {\n        return {\n          id: d.value,\n          value: d.value,\n          fy: d.y2,\n          origX: d.x1\n        };\n      });\n      var simulation = forceSimulation(nodes).force(\"x\", forceX(function (d) {\n        return d.origX;\n      }).strength(1)).force(\"collide\", forceCollide(22)).stop();\n\n      for (var i = 0; i < 100; ++i) {\n        simulation.tick();\n      } // @ts-ignore\n\n\n      ticks = zip(ticks, nodes).map(function (d) {\n        var a = d[0];\n        var b = d[1];\n\n        if (Math.abs(b.x - b.origX) > 0.01) {\n          return Object.assign(Object.assign({}, a), {\n            x2: b.x,\n            labelX: b.x\n          });\n        }\n\n        return a;\n      });\n    }\n  } else {\n    ticks = tickValues.map(function (d) {\n      var y = Math.round(scale(d));\n      var x2 = sign * innerTickSize;\n      var labelX = sign * tickSpacing;\n      return {\n        value: d,\n        x1: 0,\n        y1: y,\n        x2: x2,\n        y2: y,\n        labelX: labelX,\n        labelY: y\n      };\n    });\n    dy = \".32em\";\n    canvas_dy = fontSize * 0.32;\n    textAnchor = sign < 0 ? \"end\" : \"start\";\n  }\n\n  return Object.assign({\n    orient: orient,\n    ticks: ticks,\n    scale: scale,\n    tickStrokeStyle: tickStrokeStyle,\n    tickLabelFill: tickLabelFill || tickStrokeStyle,\n    tickStrokeWidth: tickStrokeWidth,\n    tickStrokeDasharray: tickStrokeDasharray,\n    dy: dy,\n    canvas_dy: canvas_dy,\n    textAnchor: textAnchor,\n    fontSize: fontSize,\n    fontFamily: fontFamily,\n    fontWeight: fontWeight,\n    format: format,\n    showTickLabel: showTickLabel\n  }, rest);\n};\n\nvar drawAxisLine = function drawAxisLine(ctx, props, range) {\n  var orient = props.orient,\n      outerTickSize = props.outerTickSize,\n      strokeStyle = props.strokeStyle,\n      strokeWidth = props.strokeWidth;\n  var sign = orient === \"top\" || orient === \"left\" ? -1 : 1;\n  var xAxis = orient === \"bottom\" || orient === \"top\";\n  ctx.lineWidth = strokeWidth;\n  ctx.strokeStyle = strokeStyle;\n  ctx.beginPath();\n  var firstPoint = first(range);\n  var lastPoint = last(range);\n  var tickSize = sign * outerTickSize;\n\n  if (xAxis) {\n    ctx.moveTo(firstPoint, tickSize);\n    ctx.lineTo(firstPoint, 0);\n    ctx.lineTo(lastPoint, 0);\n    ctx.lineTo(lastPoint, tickSize);\n  } else {\n    ctx.moveTo(tickSize, firstPoint);\n    ctx.lineTo(0, firstPoint);\n    ctx.lineTo(0, lastPoint);\n    ctx.lineTo(tickSize, lastPoint);\n  }\n\n  ctx.stroke();\n};\n\nvar drawTicks = function drawTicks(ctx, result) {\n  var ticks = result.ticks,\n      tickStrokeStyle = result.tickStrokeStyle;\n\n  if (tickStrokeStyle !== undefined) {\n    ctx.strokeStyle = tickStrokeStyle;\n    ctx.fillStyle = tickStrokeStyle;\n  }\n\n  ticks.forEach(function (tick) {\n    drawEachTick(ctx, tick, result);\n  });\n};\n\nvar drawGridLine = function drawGridLine(ctx, tick, result, moreProps) {\n  var orient = result.orient,\n      gridLinesStrokeWidth = result.gridLinesStrokeWidth,\n      gridLinesStrokeStyle = result.gridLinesStrokeStyle,\n      gridLinesStrokeDasharray = result.gridLinesStrokeDasharray;\n  var chartConfig = moreProps.chartConfig;\n  var height = chartConfig.height,\n      width = chartConfig.width;\n\n  if (gridLinesStrokeStyle !== undefined) {\n    ctx.strokeStyle = gridLinesStrokeStyle;\n  }\n\n  ctx.beginPath();\n  var sign = orient === \"top\" || orient === \"left\" ? 1 : -1;\n\n  switch (orient) {\n    case \"top\":\n    case \"bottom\":\n      ctx.moveTo(tick.x1, 0);\n      ctx.lineTo(tick.x2, sign * height);\n      break;\n\n    default:\n      ctx.moveTo(0, tick.y1);\n      ctx.lineTo(sign * width, tick.y2);\n      break;\n  }\n\n  ctx.lineWidth = gridLinesStrokeWidth;\n  var lineDash = getStrokeDasharrayCanvas(gridLinesStrokeDasharray);\n  ctx.setLineDash(lineDash);\n  ctx.stroke();\n};\n\nvar drawEachTick = function drawEachTick(ctx, tick, result) {\n  var tickStrokeWidth = result.tickStrokeWidth,\n      tickStrokeDasharray = result.tickStrokeDasharray;\n  ctx.beginPath();\n  ctx.moveTo(tick.x1, tick.y1);\n  ctx.lineTo(tick.x2, tick.y2);\n  ctx.lineWidth = tickStrokeWidth;\n  var lineDash = getStrokeDasharrayCanvas(tickStrokeDasharray);\n  ctx.setLineDash(lineDash);\n  ctx.stroke();\n};\n\nvar drawEachTickLabel = function drawEachTickLabel(ctx, tick, result) {\n  var canvas_dy = result.canvas_dy,\n      format = result.format;\n  var text = format(tick.value);\n  ctx.beginPath();\n  ctx.fillText(text, tick.labelX, tick.labelY + canvas_dy);\n};","map":null,"metadata":{},"sourceType":"module"}