{"ast":null,"code":"import _classCallCheck from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/taehyunpark/Desktop/Work/Class4-Team5-Oco/upbit_clone/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport * as React from \"react\";\nimport { isDefined, isNotDefined, getAxisCanvas, GenericChartComponent } from \"@react-financial-charts/core\";\n/**\n * `KagiSeries` tracks price movement mostly independantly of time.\n */\n\nexport var KagiSeries = /*#__PURE__*/function (_React$Component) {\n  _inherits(KagiSeries, _React$Component);\n\n  var _super = _createSuper(KagiSeries);\n\n  function KagiSeries() {\n    var _this;\n\n    _classCallCheck(this, KagiSeries);\n\n    _this = _super.apply(this, arguments);\n\n    _this.drawOnCanvas = function (ctx, moreProps) {\n      var _this$props = _this.props,\n          stroke = _this$props.stroke,\n          strokeWidth = _this$props.strokeWidth,\n          currentValueStroke = _this$props.currentValueStroke;\n      var xAccessor = moreProps.xAccessor,\n          xScale = moreProps.xScale,\n          yScale = moreProps.chartConfig.yScale,\n          plotData = moreProps.plotData;\n\n      var paths = _this.helper(plotData, xAccessor);\n\n      var begin = true;\n      paths.forEach(function (each) {\n        // @ts-ignore\n        ctx.strokeStyle = stroke[each.type];\n\n        if (strokeWidth !== undefined) {\n          ctx.lineWidth = strokeWidth;\n        }\n\n        ctx.beginPath();\n        var prevX;\n        each.plot.forEach(function (d) {\n          var _ref = [xScale(d[0]), yScale(d[1])],\n              x1 = _ref[0],\n              y = _ref[1];\n\n          if (begin) {\n            ctx.moveTo(x1, y);\n            begin = false;\n          } else {\n            if (isDefined(prevX)) {\n              ctx.lineTo(prevX, y);\n            }\n\n            ctx.lineTo(x1, y);\n          }\n\n          prevX = x1;\n        });\n        ctx.stroke();\n      });\n      var lastPlot = paths[paths.length - 1].plot;\n      var last = lastPlot[lastPlot.length - 1];\n      ctx.beginPath();\n      ctx.lineWidth = 1;\n      var _ref2 = [xScale(last[0]), yScale(last[2]), yScale(last[3])],\n          x = _ref2[0],\n          y1 = _ref2[1],\n          y2 = _ref2[2];\n      ctx.moveTo(x, y1);\n      ctx.lineTo(x + 10, y1);\n      ctx.stroke();\n      ctx.beginPath();\n\n      if (currentValueStroke !== undefined) {\n        ctx.strokeStyle = currentValueStroke;\n      }\n\n      ctx.moveTo(x - 10, y2);\n      ctx.lineTo(x, y2);\n      ctx.stroke();\n    };\n\n    _this.helper = function (plotData, xAccessor) {\n      var kagiLine = [];\n      var kagi = {};\n      var d = plotData[0];\n      var idx = xAccessor(d); // tslint:disable-next-line: prefer-for-of\n\n      for (var i = 0; i < plotData.length; i++) {\n        d = plotData[i];\n\n        if (isNotDefined(d.close)) {\n          continue;\n        }\n\n        if (isNotDefined(kagi.type)) {\n          kagi.type = d.startAs;\n        }\n\n        if (isNotDefined(kagi.plot)) {\n          kagi.plot = [];\n        }\n\n        idx = xAccessor(d);\n        kagi.plot.push([idx, d.open]);\n\n        if (isDefined(d.changeTo)) {\n          kagi.plot.push([idx, d.changePoint]);\n          kagi.added = true;\n          kagiLine.push(kagi);\n          kagi = {\n            type: d.changeTo,\n            plot: [],\n            added: false\n          };\n          kagi.plot.push([idx, d.changePoint]);\n        }\n      }\n\n      if (!kagi.added) {\n        kagi.plot.push([idx, d.close, d.current, d.reverseAt]);\n        kagiLine.push(kagi);\n      }\n\n      return kagiLine;\n    };\n\n    return _this;\n  }\n\n  _createClass(KagiSeries, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(GenericChartComponent, {\n        canvasToDraw: getAxisCanvas,\n        canvasDraw: this.drawOnCanvas,\n        drawOn: [\"pan\"]\n      });\n    }\n  }]);\n\n  return KagiSeries;\n}(React.Component);\nKagiSeries.defaultProps = {\n  currentValueStroke: \"#000000\",\n  fill: {\n    yang: \"none\",\n    yin: \"none\"\n  },\n  stroke: {\n    yang: \"#26a69a\",\n    yin: \"#ef5350\"\n  },\n  strokeWidth: 2\n};","map":null,"metadata":{},"sourceType":"module"}