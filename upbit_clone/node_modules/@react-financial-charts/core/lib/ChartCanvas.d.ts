import { ScaleContinuousNumeric, ScaleTime } from "d3-scale";
import * as PropTypes from "prop-types";
import * as React from "react";
import { IZoomAnchorOptions } from "./zoom/zoomBehavior";
export interface ChartCanvasProps<TXAxis extends number | Date> {
    readonly clamp?: boolean | ("left" | "right" | "both") | ((domain: [number, number], items: [number, number]) => [number, number]);
    readonly className?: string;
    readonly children?: React.ReactNode;
    readonly data: any[];
    readonly defaultFocus?: boolean;
    readonly disableInteraction?: boolean;
    readonly disablePan?: boolean;
    readonly disableZoom?: boolean;
    readonly displayXAccessor?: (data: any) => TXAxis;
    readonly flipXScale?: boolean;
    readonly height: number;
    readonly margin: {
        bottom: number;
        left: number;
        right: number;
        top: number;
    };
    readonly maintainPointsPerPixelOnResize?: boolean;
    readonly minPointsPerPxThreshold?: number;
    readonly mouseMoveEvent?: boolean;
    /**
     * Called when panning left past the first data point.
     */
    readonly onLoadAfter?: (start: TXAxis, end: TXAxis) => void;
    /**
     * Called when panning right past the last data point.
     */
    readonly onLoadBefore?: (start: TXAxis, end: TXAxis) => void;
    /**
     * Click event handler.
     */
    readonly onClick?: React.MouseEventHandler<HTMLDivElement>;
    /**
     * Double click event handler.
     */
    readonly onDoubleClick?: React.MouseEventHandler<HTMLDivElement>;
    readonly padding?: number | {
        bottom: number;
        left: number;
        right: number;
        top: number;
    };
    readonly plotFull?: boolean;
    readonly pointsPerPxThreshold?: number;
    readonly postCalculator?: (plotData: any[]) => any[];
    readonly ratio: number;
    readonly seriesName: string;
    readonly useCrossHairStyleCursor?: boolean;
    readonly width: number;
    readonly xAccessor: (data: any) => TXAxis;
    readonly xExtents: ((data: any[]) => [TXAxis, TXAxis]) | (((data: any[]) => TXAxis) | TXAxis)[];
    readonly xScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>;
    readonly zIndex?: number;
    readonly zoomAnchor?: (options: IZoomAnchorOptions<any, TXAxis>) => TXAxis;
    readonly zoomMultiplier?: number;
}
interface ChartCanvasState<TXAxis extends number | Date> {
    xAccessor?: (data: any) => TXAxis;
    displayXAccessor?: any;
    filterData?: any;
    chartConfig?: any;
    plotData: any[];
    xScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>;
}
export declare class ChartCanvas<TXAxis extends number | Date> extends React.Component<ChartCanvasProps<TXAxis>, ChartCanvasState<TXAxis>> {
    static defaultProps: {
        clamp: boolean;
        className: string;
        defaultFocus: boolean;
        disablePan: boolean;
        disableInteraction: boolean;
        disableZoom: boolean;
        flipXScale: boolean;
        maintainPointsPerPixelOnResize: boolean;
        margin: {
            top: number;
            right: number;
            bottom: number;
            left: number;
        };
        minPointsPerPxThreshold: number;
        mouseMoveEvent: boolean;
        postCalculator: (d: any) => any;
        padding: number;
        pointsPerPxThreshold: number;
        useCrossHairStyleCursor: boolean;
        xAccessor: (data: any) => any;
        xExtents: any[];
        zIndex: number;
        zoomAnchor: <TData, TXAxis_1 extends number | Date>(options: IZoomAnchorOptions<TData, TXAxis_1>) => TXAxis_1;
        zoomMultiplier: number;
    };
    static childContextTypes: {
        plotData: PropTypes.Requireable<any[]>;
        fullData: PropTypes.Requireable<any[]>;
        chartConfig: PropTypes.Validator<(PropTypes.InferProps<{
            id: PropTypes.Validator<string | number>;
            origin: PropTypes.Validator<(number | null | undefined)[]>;
            padding: PropTypes.Requireable<number | PropTypes.InferProps<{
                top: PropTypes.Requireable<number>;
                bottom: PropTypes.Requireable<number>;
            }>>;
            yExtents: PropTypes.Requireable<(((...args: any[]) => any) | null | undefined)[]>;
            yExtentsProvider: PropTypes.Requireable<(...args: any[]) => any>;
            yScale: PropTypes.Validator<(...args: any[]) => any>;
            mouseCoordinates: PropTypes.Requireable<PropTypes.InferProps<{
                at: PropTypes.Requireable<string>;
                format: PropTypes.Requireable<(...args: any[]) => any>;
            }>>;
            width: PropTypes.Validator<number>;
            height: PropTypes.Validator<number>;
        }> | null | undefined)[]>;
        xScale: PropTypes.Validator<(...args: any[]) => any>;
        xAccessor: PropTypes.Validator<(...args: any[]) => any>;
        displayXAccessor: PropTypes.Validator<(...args: any[]) => any>;
        width: PropTypes.Validator<number>;
        height: PropTypes.Validator<number>;
        margin: PropTypes.Validator<object>;
        ratio: PropTypes.Validator<number>;
        getCanvasContexts: PropTypes.Requireable<(...args: any[]) => any>;
        xAxisZoom: PropTypes.Requireable<(...args: any[]) => any>;
        yAxisZoom: PropTypes.Requireable<(...args: any[]) => any>;
        amIOnTop: PropTypes.Requireable<(...args: any[]) => any>;
        redraw: PropTypes.Requireable<(...args: any[]) => any>;
        subscribe: PropTypes.Requireable<(...args: any[]) => any>;
        unsubscribe: PropTypes.Requireable<(...args: any[]) => any>;
        setCursorClass: PropTypes.Requireable<(...args: any[]) => any>;
        generateSubscriptionId: PropTypes.Requireable<(...args: any[]) => any>;
        getMutableState: PropTypes.Requireable<(...args: any[]) => any>;
    };
    private readonly canvasContainerRef;
    private readonly eventCaptureRef;
    private finalPinch?;
    private fullData;
    private lastSubscriptionId;
    private mutableState;
    private panInProgress;
    private prevMouseXY?;
    private subscriptions;
    private waitingForPinchZoomAnimationFrame?;
    private waitingForPanAnimationFrame?;
    private waitingForMouseMoveAnimationFrame?;
    private hackyWayToStopPanBeyondBounds__plotData?;
    private hackyWayToStopPanBeyondBounds__domain?;
    constructor(props: ChartCanvasProps<TXAxis>);
    getMutableState: () => {};
    getDataInfo: () => {
        fullData: any[];
        xAccessor?: ((data: any) => TXAxis) | undefined;
        displayXAccessor?: any;
        filterData?: any;
        chartConfig?: any;
        plotData: any[];
        xScale: ScaleTime<number, number> | ScaleContinuousNumeric<number, number>;
    };
    getCanvasContexts: () => import("./CanvasContainer").ICanvasContexts | undefined;
    generateSubscriptionId: () => number;
    clearBothCanvas(): void;
    clearMouseCanvas(): void;
    clearThreeCanvas(): void;
    subscribe: (id: string, rest: any) => void;
    unsubscribe: (id: string) => void;
    getAllPanConditions: () => any[];
    setCursorClass: (className: string) => void;
    amIOnTop: (id: string) => boolean;
    handleContextMenu: (mouseXY: number[], e: React.MouseEvent) => void;
    calculateStateForDomain: (newDomain: any) => {
        xScale: ScaleTime<number, number> | ScaleContinuousNumeric<number, number>;
        plotData: any;
        chartConfig: any[];
    };
    pinchZoomHelper: (initialPinch: any, finalPinch: any) => {
        chartConfig: any[];
        xScale: ScaleTime<number, number> | ScaleContinuousNumeric<number, number>;
        plotData: any;
        mouseXY: any;
        currentItem: any;
    };
    cancelDrag(): void;
    handlePinchZoom: (initialPinch: any, finalPinch: any, e: any) => void;
    handlePinchZoomEnd: (initialPinch: any, e: any) => void;
    handleZoom: (zoomDirection: any, mouseXY: any, e: any) => void;
    xAxisZoom: (newDomain: any) => void;
    yAxisZoom: (chartId: string, newDomain: any) => void;
    triggerEvent(type: any, props?: any, e?: any): void;
    draw: (props: any) => void;
    redraw: () => void;
    panHelper: (mouseXY: number[], initialXScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>, { dx, dy }: {
        dx: number;
        dy: number;
    }, chartsToPan: string[]) => {
        xScale: ScaleTime<number, number> | ScaleContinuousNumeric<number, number>;
        plotData: any;
        chartConfig: any[];
        mouseXY: number[];
        currentCharts: any;
        currentItem: any;
    };
    handlePan: (mousePosition: number[], panStartXScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>, dxdy: {
        dx: number;
        dy: number;
    }, chartsToPan: string[], e: React.MouseEvent) => void;
    handlePanEnd: (mousePosition: number[], panStartXScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>, dxdy: {
        dx: number;
        dy: number;
    }, chartsToPan: string[], e: React.MouseEvent | React.TouchEvent) => void;
    handleMouseDown: (_: number[], __: string[], e: React.MouseEvent) => void;
    handleMouseEnter: (e: React.MouseEvent) => void;
    handleMouseMove: (mouseXY: number[], _: string, e: any) => void;
    handleMouseLeave: (e: any) => void;
    handleDragStart: ({ startPos }: any, e: any) => void;
    handleDrag: ({ startPos, mouseXY }: {
        startPos: number[];
        mouseXY: number[];
    }, e: React.MouseEvent) => void;
    handleDragEnd: ({ mouseXY }: {
        mouseXY: number[];
    }, e: React.MouseEvent) => void;
    handleClick: (_: number[], e: React.MouseEvent) => void;
    handleDoubleClick: (_: number[], e: React.MouseEvent) => void;
    getChildContext(): {
        fullData: any[];
        plotData: any[];
        width: number;
        height: number;
        chartConfig: any;
        xScale: ScaleTime<number, number> | ScaleContinuousNumeric<number, number>;
        xAccessor: ((data: any) => TXAxis) | undefined;
        displayXAccessor: any;
        margin: {
            bottom: number;
            left: number;
            right: number;
            top: number;
        };
        ratio: number;
        xAxisZoom: (newDomain: any) => void;
        yAxisZoom: (chartId: string, newDomain: any) => void;
        getCanvasContexts: () => import("./CanvasContainer").ICanvasContexts | undefined;
        redraw: () => void;
        subscribe: (id: string, rest: any) => void;
        unsubscribe: (id: string) => void;
        generateSubscriptionId: () => number;
        getMutableState: () => {};
        amIOnTop: (id: string) => boolean;
        setCursorClass: (className: string) => void;
    };
    UNSAFE_componentWillReceiveProps(nextProps: ChartCanvasProps<TXAxis>): void;
    resetYDomain: (chartId?: string | undefined) => void;
    shouldComponentUpdate(): boolean;
    render(): JSX.Element;
}
export {};
